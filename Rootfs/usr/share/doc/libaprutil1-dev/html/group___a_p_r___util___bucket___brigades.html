<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>Apache Portable Runtime Utility Library: Bucket Brigades</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Apache Portable Runtime Utility Library
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Bucket Brigades<div class="ingroups"><a class="el" href="group___a_p_r___util.html">APR Utility Functions</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapr__bucket__type__t.html">apr_bucket_type_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapr__bucket.html">apr_bucket</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapr__bucket__brigade.html">apr_bucket_brigade</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapr__bucket__refcount.html">apr_bucket_refcount</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapr__bucket__heap.html">apr_bucket_heap</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapr__bucket__pool.html">apr_bucket_pool</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapr__bucket__mmap.html">apr_bucket_mmap</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structapr__bucket__file.html">apr_bucket_file</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionapr__bucket__structs.html">apr_bucket_structs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga82bf404af30875135c65e2c13ad035e5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga82bf404af30875135c65e2c13ad035e5">APR_BUCKET_BUFF_SIZE</a>&#160;&#160;&#160;8000</td></tr>
<tr class="separator:ga82bf404af30875135c65e2c13ad035e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1dfe8bf117d10e7dc5b8e0c08f0ebb2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#gae1dfe8bf117d10e7dc5b8e0c08f0ebb2">APR_BRIGADE_CHECK_CONSISTENCY</a>(b)</td></tr>
<tr class="separator:gae1dfe8bf117d10e7dc5b8e0c08f0ebb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedaeb3fbe71aac408377471b8a54dc08"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#gaedaeb3fbe71aac408377471b8a54dc08">APR_BUCKET_CHECK_CONSISTENCY</a>(e)</td></tr>
<tr class="separator:gaedaeb3fbe71aac408377471b8a54dc08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga858da66dccab1e063415678bb115788a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga858da66dccab1e063415678bb115788a">APR_BRIGADE_SENTINEL</a>(b)&#160;&#160;&#160;APR_RING_SENTINEL(&amp;(b)-&gt;list, <a class="el" href="structapr__bucket.html">apr_bucket</a>, link)</td></tr>
<tr class="separator:ga858da66dccab1e063415678bb115788a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga836f61da6cce15074eff257ce4b6fc0f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga836f61da6cce15074eff257ce4b6fc0f">APR_BRIGADE_EMPTY</a>(b)&#160;&#160;&#160;APR_RING_EMPTY(&amp;(b)-&gt;list, <a class="el" href="structapr__bucket.html">apr_bucket</a>, link)</td></tr>
<tr class="separator:ga836f61da6cce15074eff257ce4b6fc0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5826a11eb6ba90786a94282f806c230"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#gab5826a11eb6ba90786a94282f806c230">APR_BRIGADE_FIRST</a>(b)&#160;&#160;&#160;APR_RING_FIRST(&amp;(b)-&gt;list)</td></tr>
<tr class="separator:gab5826a11eb6ba90786a94282f806c230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40e0ef2a904aa519ca9d63288dee0b4d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga40e0ef2a904aa519ca9d63288dee0b4d">APR_BRIGADE_LAST</a>(b)&#160;&#160;&#160;APR_RING_LAST(&amp;(b)-&gt;list)</td></tr>
<tr class="separator:ga40e0ef2a904aa519ca9d63288dee0b4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6dc39d8757e18941a6fb069b0c18fbd3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga6dc39d8757e18941a6fb069b0c18fbd3">APR_BRIGADE_INSERT_HEAD</a>(b, e)</td></tr>
<tr class="separator:ga6dc39d8757e18941a6fb069b0c18fbd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5447595f8374296c5ffe208db39b2f5d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga5447595f8374296c5ffe208db39b2f5d">APR_BRIGADE_INSERT_TAIL</a>(b, e)</td></tr>
<tr class="separator:ga5447595f8374296c5ffe208db39b2f5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cecbc89be912ce9ab24c889eb8f955b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga7cecbc89be912ce9ab24c889eb8f955b">APR_BRIGADE_CONCAT</a>(a, b)</td></tr>
<tr class="separator:ga7cecbc89be912ce9ab24c889eb8f955b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52ba212f76507a79ccae213875150ad1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga52ba212f76507a79ccae213875150ad1">APR_BRIGADE_PREPEND</a>(a, b)</td></tr>
<tr class="separator:ga52ba212f76507a79ccae213875150ad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae012adeccda754eabc42b7855bec081e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#gae012adeccda754eabc42b7855bec081e">APR_BUCKET_INSERT_BEFORE</a>(a, b)</td></tr>
<tr class="separator:gae012adeccda754eabc42b7855bec081e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f8114b7316d1fef1deb95abc8f02341"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga1f8114b7316d1fef1deb95abc8f02341">APR_BUCKET_INSERT_AFTER</a>(a, b)</td></tr>
<tr class="separator:ga1f8114b7316d1fef1deb95abc8f02341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7171f690b203d548a5b6ae0b079068d8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga7171f690b203d548a5b6ae0b079068d8">APR_BUCKET_NEXT</a>(e)&#160;&#160;&#160;APR_RING_NEXT((e), link)</td></tr>
<tr class="separator:ga7171f690b203d548a5b6ae0b079068d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf229fecd4174efd4d6a9774e3048ae28"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#gaf229fecd4174efd4d6a9774e3048ae28">APR_BUCKET_PREV</a>(e)&#160;&#160;&#160;APR_RING_PREV((e), link)</td></tr>
<tr class="separator:gaf229fecd4174efd4d6a9774e3048ae28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c46a1b717a87b68bd98b425e0c64977"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga2c46a1b717a87b68bd98b425e0c64977">APR_BUCKET_REMOVE</a>(e)&#160;&#160;&#160;APR_RING_REMOVE((e), link)</td></tr>
<tr class="separator:ga2c46a1b717a87b68bd98b425e0c64977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00c2e104125f124c3a52627863432de9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga00c2e104125f124c3a52627863432de9">APR_BUCKET_INIT</a>(e)&#160;&#160;&#160;APR_RING_ELEM_INIT((e), link)</td></tr>
<tr class="separator:ga00c2e104125f124c3a52627863432de9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga506cb29cc1ec1abeb487e01b122bd4d9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga506cb29cc1ec1abeb487e01b122bd4d9">APR_BUCKET_IS_METADATA</a>(e)&#160;&#160;&#160;((e)-&gt;type-&gt;is_metadata)</td></tr>
<tr class="separator:ga506cb29cc1ec1abeb487e01b122bd4d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24105da0bb755a775c4b2a519d7c25f9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga24105da0bb755a775c4b2a519d7c25f9">APR_BUCKET_IS_FLUSH</a>(e)&#160;&#160;&#160;((e)-&gt;type == &amp;<a class="el" href="group___a_p_r___util___bucket___brigades.html#gaecc113cfcc7751dfe70876437a2f51d7">apr_bucket_type_flush</a>)</td></tr>
<tr class="separator:ga24105da0bb755a775c4b2a519d7c25f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89b225e1c08473766eec719b985ca0d6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga89b225e1c08473766eec719b985ca0d6">APR_BUCKET_IS_EOS</a>(e)&#160;&#160;&#160;((e)-&gt;type == &amp;<a class="el" href="group___a_p_r___util___bucket___brigades.html#ga829cac9b4843b85a902ddd64dffbfb12">apr_bucket_type_eos</a>)</td></tr>
<tr class="separator:ga89b225e1c08473766eec719b985ca0d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d54037bb6953c73d5c61f64c311d470"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga1d54037bb6953c73d5c61f64c311d470">APR_BUCKET_IS_FILE</a>(e)&#160;&#160;&#160;((e)-&gt;type == &amp;<a class="el" href="group___a_p_r___util___bucket___brigades.html#ga5f17aa7e616179411a06475ec09626e9">apr_bucket_type_file</a>)</td></tr>
<tr class="separator:ga1d54037bb6953c73d5c61f64c311d470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03e62d86c994d1d1cc9be3eb8b8f6ac6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga03e62d86c994d1d1cc9be3eb8b8f6ac6">APR_BUCKET_IS_PIPE</a>(e)&#160;&#160;&#160;((e)-&gt;type == &amp;<a class="el" href="group___a_p_r___util___bucket___brigades.html#ga334a875abb2908364a40abbfa80c401f">apr_bucket_type_pipe</a>)</td></tr>
<tr class="separator:ga03e62d86c994d1d1cc9be3eb8b8f6ac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b8315b498e4eb67efde1c83bdbe8b87"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga4b8315b498e4eb67efde1c83bdbe8b87">APR_BUCKET_IS_SOCKET</a>(e)&#160;&#160;&#160;((e)-&gt;type == &amp;<a class="el" href="group___a_p_r___util___bucket___brigades.html#gaa6d9978cc10895bdf0a4686728822a84">apr_bucket_type_socket</a>)</td></tr>
<tr class="separator:ga4b8315b498e4eb67efde1c83bdbe8b87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3dee4fbd5b4e16e5188a6cfec40b6961"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga3dee4fbd5b4e16e5188a6cfec40b6961">APR_BUCKET_IS_HEAP</a>(e)&#160;&#160;&#160;((e)-&gt;type == &amp;<a class="el" href="group___a_p_r___util___bucket___brigades.html#ga2c5608267ed7b860657f5a1c89c2f40d">apr_bucket_type_heap</a>)</td></tr>
<tr class="separator:ga3dee4fbd5b4e16e5188a6cfec40b6961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a7e7ac5fddbab4ce189e8d3007446ff"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga1a7e7ac5fddbab4ce189e8d3007446ff">APR_BUCKET_IS_TRANSIENT</a>(e)&#160;&#160;&#160;((e)-&gt;type == &amp;<a class="el" href="group___a_p_r___util___bucket___brigades.html#ga1692ced61c1966e67adc05ec2a69ce9b">apr_bucket_type_transient</a>)</td></tr>
<tr class="separator:ga1a7e7ac5fddbab4ce189e8d3007446ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53f1188c168acf7dcfabfa1ac5a08655"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga53f1188c168acf7dcfabfa1ac5a08655">APR_BUCKET_IS_IMMORTAL</a>(e)&#160;&#160;&#160;((e)-&gt;type == &amp;<a class="el" href="group___a_p_r___util___bucket___brigades.html#ga391ac24b2c85969e8efa504588b364bb">apr_bucket_type_immortal</a>)</td></tr>
<tr class="separator:ga53f1188c168acf7dcfabfa1ac5a08655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1693d49aeb0287e3b171c922c6b633d2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga1693d49aeb0287e3b171c922c6b633d2">APR_BUCKET_IS_MMAP</a>(e)&#160;&#160;&#160;((e)-&gt;type == &amp;<a class="el" href="group___a_p_r___util___bucket___brigades.html#ga63f9ce8e4d6e796921aad14a218a3b23">apr_bucket_type_mmap</a>)</td></tr>
<tr class="separator:ga1693d49aeb0287e3b171c922c6b633d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbe80a9016da6a06ab414ba61d6625d0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#gadbe80a9016da6a06ab414ba61d6625d0">APR_BUCKET_IS_POOL</a>(e)&#160;&#160;&#160;((e)-&gt;type == &amp;<a class="el" href="group___a_p_r___util___bucket___brigades.html#ga87bace819fdbf07c12497a8289b3567b">apr_bucket_type_pool</a>)</td></tr>
<tr class="separator:gadbe80a9016da6a06ab414ba61d6625d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3ccf4c383c9e7fea28354cc8e029626"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#gae3ccf4c383c9e7fea28354cc8e029626">APR_BUCKET_ALLOC_SIZE</a>&#160;&#160;&#160;APR_ALIGN_DEFAULT(2*sizeof(<a class="el" href="unionapr__bucket__structs.html">apr_bucket_structs</a>))</td></tr>
<tr class="separator:gae3ccf4c383c9e7fea28354cc8e029626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc0dae1e90a798284ed777a0c9e90ec6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#gafc0dae1e90a798284ed777a0c9e90ec6">apr_bucket_destroy</a>(e)</td></tr>
<tr class="separator:gafc0dae1e90a798284ed777a0c9e90ec6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8925c02a7f95e8c1c3986294d4678797"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga8925c02a7f95e8c1c3986294d4678797">apr_bucket_delete</a>(e)</td></tr>
<tr class="separator:ga8925c02a7f95e8c1c3986294d4678797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae44ae938c6c60e148430fdb098dcf28f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#gae44ae938c6c60e148430fdb098dcf28f">apr_bucket_read</a>(e, str, len, block)&#160;&#160;&#160;(e)-&gt;type-&gt;read(e, str, len, block)</td></tr>
<tr class="separator:gae44ae938c6c60e148430fdb098dcf28f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab00941ffd472982693eb415a964de7af"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#gab00941ffd472982693eb415a964de7af">apr_bucket_setaside</a>(e, p)&#160;&#160;&#160;(e)-&gt;type-&gt;setaside(e,p)</td></tr>
<tr class="separator:gab00941ffd472982693eb415a964de7af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5bb8827a8dd1baa6ac32682e13e9d8c2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga5bb8827a8dd1baa6ac32682e13e9d8c2">apr_bucket_split</a>(e, point)&#160;&#160;&#160;(e)-&gt;type-&gt;split(e, point)</td></tr>
<tr class="separator:ga5bb8827a8dd1baa6ac32682e13e9d8c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab33cc08b7f064d06397f312e427279c3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#gab33cc08b7f064d06397f312e427279c3">apr_bucket_copy</a>(e, c)&#160;&#160;&#160;(e)-&gt;type-&gt;copy(e, c)</td></tr>
<tr class="separator:gab33cc08b7f064d06397f312e427279c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga9f50254e85c7aad79ca289a0ba069025"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structapr__bucket__brigade.html">apr_bucket_brigade</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga9f50254e85c7aad79ca289a0ba069025">apr_bucket_brigade</a></td></tr>
<tr class="separator:ga9f50254e85c7aad79ca289a0ba069025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa17a456120961b1c5af0525f4900a457"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structapr__bucket.html">apr_bucket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#gaa17a456120961b1c5af0525f4900a457">apr_bucket</a></td></tr>
<tr class="separator:gaa17a456120961b1c5af0525f4900a457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a30babfeb6e290db124d8f9b69e49e4"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="group___a_p_r___util___bucket___brigades.html#ga9a30babfeb6e290db124d8f9b69e49e4">apr_bucket_alloc_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga9a30babfeb6e290db124d8f9b69e49e4">apr_bucket_alloc_t</a></td></tr>
<tr class="separator:ga9a30babfeb6e290db124d8f9b69e49e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a152aaf7d851c81af73b7e84dc1a8a2"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structapr__bucket__type__t.html">apr_bucket_type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga4a152aaf7d851c81af73b7e84dc1a8a2">apr_bucket_type_t</a></td></tr>
<tr class="separator:ga4a152aaf7d851c81af73b7e84dc1a8a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacdf6dc9d4c81c64834e5e509281f7f16"><td class="memItemLeft" align="right" valign="top">typedef apr_status_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#gacdf6dc9d4c81c64834e5e509281f7f16">apr_brigade_flush</a> )(<a class="el" href="structapr__bucket__brigade.html">apr_bucket_brigade</a> *bb, void *ctx)</td></tr>
<tr class="separator:gacdf6dc9d4c81c64834e5e509281f7f16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga785fd3402961b30315975b0c87c87706"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structapr__bucket__refcount.html">apr_bucket_refcount</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga785fd3402961b30315975b0c87c87706">apr_bucket_refcount</a></td></tr>
<tr class="separator:ga785fd3402961b30315975b0c87c87706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaede6e77d621d0f3f7d2685d489d01283"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structapr__bucket__heap.html">apr_bucket_heap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#gaede6e77d621d0f3f7d2685d489d01283">apr_bucket_heap</a></td></tr>
<tr class="separator:gaede6e77d621d0f3f7d2685d489d01283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga211e00d871029de148116cd24b070aed"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structapr__bucket__pool.html">apr_bucket_pool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga211e00d871029de148116cd24b070aed">apr_bucket_pool</a></td></tr>
<tr class="separator:ga211e00d871029de148116cd24b070aed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27ede7c3a29627c7d184dc7cfbc4f767"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structapr__bucket__mmap.html">apr_bucket_mmap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga27ede7c3a29627c7d184dc7cfbc4f767">apr_bucket_mmap</a></td></tr>
<tr class="separator:ga27ede7c3a29627c7d184dc7cfbc4f767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a786f7edac4d7a2c212f0fe74457b3d"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structapr__bucket__file.html">apr_bucket_file</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga1a786f7edac4d7a2c212f0fe74457b3d">apr_bucket_file</a></td></tr>
<tr class="separator:ga1a786f7edac4d7a2c212f0fe74457b3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c0929c971f94de4521fb0fea6fd3209"><td class="memItemLeft" align="right" valign="top">typedef union <a class="el" href="unionapr__bucket__structs.html">apr_bucket_structs</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga3c0929c971f94de4521fb0fea6fd3209">apr_bucket_structs</a></td></tr>
<tr class="separator:ga3c0929c971f94de4521fb0fea6fd3209"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga756973fb6392bd1026c3d96b4519776d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga756973fb6392bd1026c3d96b4519776d">apr_read_type_e</a> { <a class="el" href="group___a_p_r___util___bucket___brigades.html#gga756973fb6392bd1026c3d96b4519776da2d983f5b7fd996434e0dded171c261d8">APR_BLOCK_READ</a>, 
<a class="el" href="group___a_p_r___util___bucket___brigades.html#gga756973fb6392bd1026c3d96b4519776da42b97663ca71fbbf2e2af7c8192e5dd8">APR_NONBLOCK_READ</a>
 }</td></tr>
<tr class="separator:ga756973fb6392bd1026c3d96b4519776d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaeb422371006699c68f0ed3b496cc12a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapr__bucket__brigade.html">apr_bucket_brigade</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#gaeb422371006699c68f0ed3b496cc12a2">apr_brigade_create</a> (apr_pool_t *p, <a class="el" href="group___a_p_r___util___bucket___brigades.html#ga9a30babfeb6e290db124d8f9b69e49e4">apr_bucket_alloc_t</a> *list)</td></tr>
<tr class="separator:gaeb422371006699c68f0ed3b496cc12a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2eba1e262dece0d4444ddd25ae7b250a"><td class="memItemLeft" align="right" valign="top">apr_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga2eba1e262dece0d4444ddd25ae7b250a">apr_brigade_destroy</a> (<a class="el" href="structapr__bucket__brigade.html">apr_bucket_brigade</a> *b)</td></tr>
<tr class="separator:ga2eba1e262dece0d4444ddd25ae7b250a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd6a8378a15e8b42a57a5923a03de7f2"><td class="memItemLeft" align="right" valign="top">apr_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#gafd6a8378a15e8b42a57a5923a03de7f2">apr_brigade_cleanup</a> (void *data)</td></tr>
<tr class="separator:gafd6a8378a15e8b42a57a5923a03de7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36448fa89ab3239fd46591fbc82624e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapr__bucket__brigade.html">apr_bucket_brigade</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga36448fa89ab3239fd46591fbc82624e6">apr_brigade_split_ex</a> (<a class="el" href="structapr__bucket__brigade.html">apr_bucket_brigade</a> *b, <a class="el" href="structapr__bucket.html">apr_bucket</a> *e, <a class="el" href="structapr__bucket__brigade.html">apr_bucket_brigade</a> *a)</td></tr>
<tr class="separator:ga36448fa89ab3239fd46591fbc82624e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacaf2929f951920a464e170baf2b4c345"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapr__bucket__brigade.html">apr_bucket_brigade</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#gacaf2929f951920a464e170baf2b4c345">apr_brigade_split</a> (<a class="el" href="structapr__bucket__brigade.html">apr_bucket_brigade</a> *b, <a class="el" href="structapr__bucket.html">apr_bucket</a> *e)</td></tr>
<tr class="separator:gacaf2929f951920a464e170baf2b4c345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b2f22ba70ac9f65788014c61d4f5b76"><td class="memItemLeft" align="right" valign="top">apr_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga4b2f22ba70ac9f65788014c61d4f5b76">apr_brigade_partition</a> (<a class="el" href="structapr__bucket__brigade.html">apr_bucket_brigade</a> *b, apr_off_t point, <a class="el" href="structapr__bucket.html">apr_bucket</a> **after_point)</td></tr>
<tr class="separator:ga4b2f22ba70ac9f65788014c61d4f5b76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65075839e31fd85e2c80717f4e9e0461"><td class="memItemLeft" align="right" valign="top">apr_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga65075839e31fd85e2c80717f4e9e0461">apr_brigade_length</a> (<a class="el" href="structapr__bucket__brigade.html">apr_bucket_brigade</a> *bb, int read_all, apr_off_t *length)</td></tr>
<tr class="separator:ga65075839e31fd85e2c80717f4e9e0461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga301aeb943e68ef4b99c1ae6a18dcf78e"><td class="memItemLeft" align="right" valign="top">apr_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga301aeb943e68ef4b99c1ae6a18dcf78e">apr_brigade_flatten</a> (<a class="el" href="structapr__bucket__brigade.html">apr_bucket_brigade</a> *bb, char *c, apr_size_t *len)</td></tr>
<tr class="separator:ga301aeb943e68ef4b99c1ae6a18dcf78e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5da970af09d1a87e020db054f2d1c94"><td class="memItemLeft" align="right" valign="top">apr_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#gaa5da970af09d1a87e020db054f2d1c94">apr_brigade_pflatten</a> (<a class="el" href="structapr__bucket__brigade.html">apr_bucket_brigade</a> *bb, char **c, apr_size_t *len, apr_pool_t *pool)</td></tr>
<tr class="separator:gaa5da970af09d1a87e020db054f2d1c94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga257dece60dbdc910bc09e1fc0d7db622"><td class="memItemLeft" align="right" valign="top">apr_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga257dece60dbdc910bc09e1fc0d7db622">apr_brigade_split_line</a> (<a class="el" href="structapr__bucket__brigade.html">apr_bucket_brigade</a> *bbOut, <a class="el" href="structapr__bucket__brigade.html">apr_bucket_brigade</a> *bbIn, <a class="el" href="group___a_p_r___util___bucket___brigades.html#ga756973fb6392bd1026c3d96b4519776d">apr_read_type_e</a> block, apr_off_t maxbytes)</td></tr>
<tr class="separator:ga257dece60dbdc910bc09e1fc0d7db622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga904bdc4a9a9c800d2d2b20b4ddefa6f7"><td class="memItemLeft" align="right" valign="top">apr_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga904bdc4a9a9c800d2d2b20b4ddefa6f7">apr_brigade_to_iovec</a> (<a class="el" href="structapr__bucket__brigade.html">apr_bucket_brigade</a> *b, struct iovec *vec, int *nvec)</td></tr>
<tr class="separator:ga904bdc4a9a9c800d2d2b20b4ddefa6f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga382871c1aec5cf9fbbcf19d67cff6b43"><td class="memItemLeft" align="right" valign="top">apr_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga382871c1aec5cf9fbbcf19d67cff6b43">apr_brigade_vputstrs</a> (<a class="el" href="structapr__bucket__brigade.html">apr_bucket_brigade</a> *b, <a class="el" href="group___a_p_r___util___bucket___brigades.html#gacdf6dc9d4c81c64834e5e509281f7f16">apr_brigade_flush</a> flush, void *ctx, va_list va)</td></tr>
<tr class="separator:ga382871c1aec5cf9fbbcf19d67cff6b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7242dae50995fc1a9174476ca3053d99"><td class="memItemLeft" align="right" valign="top">apr_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga7242dae50995fc1a9174476ca3053d99">apr_brigade_write</a> (<a class="el" href="structapr__bucket__brigade.html">apr_bucket_brigade</a> *b, <a class="el" href="group___a_p_r___util___bucket___brigades.html#gacdf6dc9d4c81c64834e5e509281f7f16">apr_brigade_flush</a> flush, void *ctx, const char *str, apr_size_t nbyte)</td></tr>
<tr class="separator:ga7242dae50995fc1a9174476ca3053d99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc116a4359b717cd3a78a19ddf169486"><td class="memItemLeft" align="right" valign="top">apr_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#gafc116a4359b717cd3a78a19ddf169486">apr_brigade_writev</a> (<a class="el" href="structapr__bucket__brigade.html">apr_bucket_brigade</a> *b, <a class="el" href="group___a_p_r___util___bucket___brigades.html#gacdf6dc9d4c81c64834e5e509281f7f16">apr_brigade_flush</a> flush, void *ctx, const struct iovec *vec, apr_size_t nvec)</td></tr>
<tr class="separator:gafc116a4359b717cd3a78a19ddf169486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d1fed26db94e3006223098737a06f5a"><td class="memItemLeft" align="right" valign="top">apr_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga2d1fed26db94e3006223098737a06f5a">apr_brigade_puts</a> (<a class="el" href="structapr__bucket__brigade.html">apr_bucket_brigade</a> *bb, <a class="el" href="group___a_p_r___util___bucket___brigades.html#gacdf6dc9d4c81c64834e5e509281f7f16">apr_brigade_flush</a> flush, void *ctx, const char *str)</td></tr>
<tr class="separator:ga2d1fed26db94e3006223098737a06f5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga362999cb255297fd0fd433f03236302d"><td class="memItemLeft" align="right" valign="top">apr_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga362999cb255297fd0fd433f03236302d">apr_brigade_putc</a> (<a class="el" href="structapr__bucket__brigade.html">apr_bucket_brigade</a> *b, <a class="el" href="group___a_p_r___util___bucket___brigades.html#gacdf6dc9d4c81c64834e5e509281f7f16">apr_brigade_flush</a> flush, void *ctx, const char c)</td></tr>
<tr class="separator:ga362999cb255297fd0fd433f03236302d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f27949d92196cbf150b7d6256cbf4b7"><td class="memItemLeft" align="right" valign="top">apr_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga1f27949d92196cbf150b7d6256cbf4b7">apr_brigade_putstrs</a> (<a class="el" href="structapr__bucket__brigade.html">apr_bucket_brigade</a> *b, <a class="el" href="group___a_p_r___util___bucket___brigades.html#gacdf6dc9d4c81c64834e5e509281f7f16">apr_brigade_flush</a> flush, void *ctx,...)</td></tr>
<tr class="separator:ga1f27949d92196cbf150b7d6256cbf4b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4120ba3834c545db3b9229d858e33b47"><td class="memItemLeft" align="right" valign="top">apr_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga4120ba3834c545db3b9229d858e33b47">apr_brigade_printf</a> (<a class="el" href="structapr__bucket__brigade.html">apr_bucket_brigade</a> *b, <a class="el" href="group___a_p_r___util___bucket___brigades.html#gacdf6dc9d4c81c64834e5e509281f7f16">apr_brigade_flush</a> flush, void *ctx, const char *fmt,...)</td></tr>
<tr class="separator:ga4120ba3834c545db3b9229d858e33b47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e1af8c10946264e1bb37a3f56e4bfd8"><td class="memItemLeft" align="right" valign="top">apr_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga9e1af8c10946264e1bb37a3f56e4bfd8">apr_brigade_vprintf</a> (<a class="el" href="structapr__bucket__brigade.html">apr_bucket_brigade</a> *b, <a class="el" href="group___a_p_r___util___bucket___brigades.html#gacdf6dc9d4c81c64834e5e509281f7f16">apr_brigade_flush</a> flush, void *ctx, const char *fmt, va_list va)</td></tr>
<tr class="separator:ga9e1af8c10946264e1bb37a3f56e4bfd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c4981f7050333a181e440e753c20555"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapr__bucket.html">apr_bucket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga7c4981f7050333a181e440e753c20555">apr_brigade_insert_file</a> (<a class="el" href="structapr__bucket__brigade.html">apr_bucket_brigade</a> *bb, apr_file_t *f, apr_off_t start, apr_off_t len, apr_pool_t *p)</td></tr>
<tr class="separator:ga7c4981f7050333a181e440e753c20555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d96fa729a17a86dc5221958e8c13c96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga9a30babfeb6e290db124d8f9b69e49e4">apr_bucket_alloc_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga2d96fa729a17a86dc5221958e8c13c96">apr_bucket_alloc_create</a> (apr_pool_t *p)</td></tr>
<tr class="separator:ga2d96fa729a17a86dc5221958e8c13c96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga252642139099350d0b987889d5c0868c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga9a30babfeb6e290db124d8f9b69e49e4">apr_bucket_alloc_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga252642139099350d0b987889d5c0868c">apr_bucket_alloc_create_ex</a> (apr_allocator_t *allocator)</td></tr>
<tr class="separator:ga252642139099350d0b987889d5c0868c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5eb58cc232851c8449ba1d98d049a0a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#gaf5eb58cc232851c8449ba1d98d049a0a">apr_bucket_alloc_destroy</a> (<a class="el" href="group___a_p_r___util___bucket___brigades.html#ga9a30babfeb6e290db124d8f9b69e49e4">apr_bucket_alloc_t</a> *list)</td></tr>
<tr class="separator:gaf5eb58cc232851c8449ba1d98d049a0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae47c2235a3740432f4a0990fccfe4102"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#gae47c2235a3740432f4a0990fccfe4102">apr_bucket_alloc</a> (apr_size_t size, <a class="el" href="group___a_p_r___util___bucket___brigades.html#ga9a30babfeb6e290db124d8f9b69e49e4">apr_bucket_alloc_t</a> *list)</td></tr>
<tr class="separator:gae47c2235a3740432f4a0990fccfe4102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga951beb3a8249648214e130ab06275a3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga951beb3a8249648214e130ab06275a3a">apr_bucket_free</a> (void *block)</td></tr>
<tr class="separator:ga951beb3a8249648214e130ab06275a3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6135b83d9f7bd7e1b60dbc761a3ca5f"><td class="memItemLeft" align="right" valign="top">apr_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#gae6135b83d9f7bd7e1b60dbc761a3ca5f">apr_bucket_setaside_noop</a> (<a class="el" href="structapr__bucket.html">apr_bucket</a> *data, apr_pool_t *pool)</td></tr>
<tr class="separator:gae6135b83d9f7bd7e1b60dbc761a3ca5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade52b057161f657a6b298d9c6a78b339"><td class="memItemLeft" align="right" valign="top">apr_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#gade52b057161f657a6b298d9c6a78b339">apr_bucket_setaside_notimpl</a> (<a class="el" href="structapr__bucket.html">apr_bucket</a> *data, apr_pool_t *pool)</td></tr>
<tr class="separator:gade52b057161f657a6b298d9c6a78b339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga305766ff39440711da93e72f5b348a3a"><td class="memItemLeft" align="right" valign="top">apr_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga305766ff39440711da93e72f5b348a3a">apr_bucket_split_notimpl</a> (<a class="el" href="structapr__bucket.html">apr_bucket</a> *data, apr_size_t point)</td></tr>
<tr class="separator:ga305766ff39440711da93e72f5b348a3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fc17c10cee2abf02557669f6f507e89"><td class="memItemLeft" align="right" valign="top">apr_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga5fc17c10cee2abf02557669f6f507e89">apr_bucket_copy_notimpl</a> (<a class="el" href="structapr__bucket.html">apr_bucket</a> *e, <a class="el" href="structapr__bucket.html">apr_bucket</a> **c)</td></tr>
<tr class="separator:ga5fc17c10cee2abf02557669f6f507e89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09221bea9541ca2340a4e8b5e1e7ac56"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga09221bea9541ca2340a4e8b5e1e7ac56">apr_bucket_destroy_noop</a> (void *data)</td></tr>
<tr class="separator:ga09221bea9541ca2340a4e8b5e1e7ac56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9fd8c7d9e42dd04b8f153072655e875c"><td class="memItemLeft" align="right" valign="top">apr_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga9fd8c7d9e42dd04b8f153072655e875c">apr_bucket_simple_split</a> (<a class="el" href="structapr__bucket.html">apr_bucket</a> *b, apr_size_t point)</td></tr>
<tr class="separator:ga9fd8c7d9e42dd04b8f153072655e875c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga123c95e832734f92e6f1139b6a68cfa6"><td class="memItemLeft" align="right" valign="top">apr_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga123c95e832734f92e6f1139b6a68cfa6">apr_bucket_simple_copy</a> (<a class="el" href="structapr__bucket.html">apr_bucket</a> *a, <a class="el" href="structapr__bucket.html">apr_bucket</a> **b)</td></tr>
<tr class="separator:ga123c95e832734f92e6f1139b6a68cfa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga562251ac5776e88f7384158b85e74be8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapr__bucket.html">apr_bucket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga562251ac5776e88f7384158b85e74be8">apr_bucket_shared_make</a> (<a class="el" href="structapr__bucket.html">apr_bucket</a> *b, void *data, apr_off_t start, apr_size_t length)</td></tr>
<tr class="separator:ga562251ac5776e88f7384158b85e74be8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43c7dc7e3eb961a91bbc0b69a47e503c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga43c7dc7e3eb961a91bbc0b69a47e503c">apr_bucket_shared_destroy</a> (void *data)</td></tr>
<tr class="separator:ga43c7dc7e3eb961a91bbc0b69a47e503c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga871e54ba20487a2085a73a673ffa4110"><td class="memItemLeft" align="right" valign="top">apr_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga871e54ba20487a2085a73a673ffa4110">apr_bucket_shared_split</a> (<a class="el" href="structapr__bucket.html">apr_bucket</a> *b, apr_size_t point)</td></tr>
<tr class="separator:ga871e54ba20487a2085a73a673ffa4110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e9a035d340ef6b4279b178eff614670"><td class="memItemLeft" align="right" valign="top">apr_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga2e9a035d340ef6b4279b178eff614670">apr_bucket_shared_copy</a> (<a class="el" href="structapr__bucket.html">apr_bucket</a> *a, <a class="el" href="structapr__bucket.html">apr_bucket</a> **b)</td></tr>
<tr class="separator:ga2e9a035d340ef6b4279b178eff614670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac308b459ecdab87e94b12adad1b8760"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapr__bucket.html">apr_bucket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#gaac308b459ecdab87e94b12adad1b8760">apr_bucket_eos_create</a> (<a class="el" href="group___a_p_r___util___bucket___brigades.html#ga9a30babfeb6e290db124d8f9b69e49e4">apr_bucket_alloc_t</a> *list)</td></tr>
<tr class="separator:gaac308b459ecdab87e94b12adad1b8760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06312ba339cb0ec1844b698d30e754c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapr__bucket.html">apr_bucket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga06312ba339cb0ec1844b698d30e754c4">apr_bucket_eos_make</a> (<a class="el" href="structapr__bucket.html">apr_bucket</a> *b)</td></tr>
<tr class="separator:ga06312ba339cb0ec1844b698d30e754c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48347f3f7d5738cdb61fe35c25c09666"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapr__bucket.html">apr_bucket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga48347f3f7d5738cdb61fe35c25c09666">apr_bucket_flush_create</a> (<a class="el" href="group___a_p_r___util___bucket___brigades.html#ga9a30babfeb6e290db124d8f9b69e49e4">apr_bucket_alloc_t</a> *list)</td></tr>
<tr class="separator:ga48347f3f7d5738cdb61fe35c25c09666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee543b95249a320a27ae9bb03e2c4f23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapr__bucket.html">apr_bucket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#gaee543b95249a320a27ae9bb03e2c4f23">apr_bucket_flush_make</a> (<a class="el" href="structapr__bucket.html">apr_bucket</a> *b)</td></tr>
<tr class="separator:gaee543b95249a320a27ae9bb03e2c4f23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad81543da24b144c0e100dd1e6d843adb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapr__bucket.html">apr_bucket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#gad81543da24b144c0e100dd1e6d843adb">apr_bucket_immortal_create</a> (const char *buf, apr_size_t nbyte, <a class="el" href="group___a_p_r___util___bucket___brigades.html#ga9a30babfeb6e290db124d8f9b69e49e4">apr_bucket_alloc_t</a> *list)</td></tr>
<tr class="separator:gad81543da24b144c0e100dd1e6d843adb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33b21eb55cad9d28b5cdd40ad4181774"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapr__bucket.html">apr_bucket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga33b21eb55cad9d28b5cdd40ad4181774">apr_bucket_immortal_make</a> (<a class="el" href="structapr__bucket.html">apr_bucket</a> *b, const char *buf, apr_size_t nbyte)</td></tr>
<tr class="separator:ga33b21eb55cad9d28b5cdd40ad4181774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga554f2d87c718f30a9259d52c6f81a405"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapr__bucket.html">apr_bucket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga554f2d87c718f30a9259d52c6f81a405">apr_bucket_transient_create</a> (const char *buf, apr_size_t nbyte, <a class="el" href="group___a_p_r___util___bucket___brigades.html#ga9a30babfeb6e290db124d8f9b69e49e4">apr_bucket_alloc_t</a> *list)</td></tr>
<tr class="separator:ga554f2d87c718f30a9259d52c6f81a405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e1f9a0ae64781ff4430d08c25e6e831"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapr__bucket.html">apr_bucket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga7e1f9a0ae64781ff4430d08c25e6e831">apr_bucket_transient_make</a> (<a class="el" href="structapr__bucket.html">apr_bucket</a> *b, const char *buf, apr_size_t nbyte)</td></tr>
<tr class="separator:ga7e1f9a0ae64781ff4430d08c25e6e831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadde6843cfe311a60d290adc1d6635cac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapr__bucket.html">apr_bucket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#gadde6843cfe311a60d290adc1d6635cac">apr_bucket_heap_create</a> (const char *buf, apr_size_t nbyte, void(*free_func)(void *data), <a class="el" href="group___a_p_r___util___bucket___brigades.html#ga9a30babfeb6e290db124d8f9b69e49e4">apr_bucket_alloc_t</a> *list)</td></tr>
<tr class="separator:gadde6843cfe311a60d290adc1d6635cac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71de285204d21507420068f05b12a541"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapr__bucket.html">apr_bucket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga71de285204d21507420068f05b12a541">apr_bucket_heap_make</a> (<a class="el" href="structapr__bucket.html">apr_bucket</a> *b, const char *buf, apr_size_t nbyte, void(*free_func)(void *data))</td></tr>
<tr class="separator:ga71de285204d21507420068f05b12a541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga154ea763ee9de4ccb8692b9e3b60ebb2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapr__bucket.html">apr_bucket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga154ea763ee9de4ccb8692b9e3b60ebb2">apr_bucket_pool_create</a> (const char *buf, apr_size_t length, apr_pool_t *pool, <a class="el" href="group___a_p_r___util___bucket___brigades.html#ga9a30babfeb6e290db124d8f9b69e49e4">apr_bucket_alloc_t</a> *list)</td></tr>
<tr class="separator:ga154ea763ee9de4ccb8692b9e3b60ebb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01197c5b2cda6382354628cecdeae145"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapr__bucket.html">apr_bucket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga01197c5b2cda6382354628cecdeae145">apr_bucket_pool_make</a> (<a class="el" href="structapr__bucket.html">apr_bucket</a> *b, const char *buf, apr_size_t length, apr_pool_t *pool)</td></tr>
<tr class="separator:ga01197c5b2cda6382354628cecdeae145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee338c7d218ce1fbbf8c1aefedcc0632"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapr__bucket.html">apr_bucket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#gaee338c7d218ce1fbbf8c1aefedcc0632">apr_bucket_mmap_create</a> (apr_mmap_t *mm, apr_off_t start, apr_size_t length, <a class="el" href="group___a_p_r___util___bucket___brigades.html#ga9a30babfeb6e290db124d8f9b69e49e4">apr_bucket_alloc_t</a> *list)</td></tr>
<tr class="separator:gaee338c7d218ce1fbbf8c1aefedcc0632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab561ac92d1811e5a2589783536e64a1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapr__bucket.html">apr_bucket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#gab561ac92d1811e5a2589783536e64a1a">apr_bucket_mmap_make</a> (<a class="el" href="structapr__bucket.html">apr_bucket</a> *b, apr_mmap_t *mm, apr_off_t start, apr_size_t length)</td></tr>
<tr class="separator:gab561ac92d1811e5a2589783536e64a1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd9f08b40eb2204cd93b42e58338aeb2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapr__bucket.html">apr_bucket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#gacd9f08b40eb2204cd93b42e58338aeb2">apr_bucket_socket_create</a> (apr_socket_t *thissock, <a class="el" href="group___a_p_r___util___bucket___brigades.html#ga9a30babfeb6e290db124d8f9b69e49e4">apr_bucket_alloc_t</a> *list)</td></tr>
<tr class="separator:gacd9f08b40eb2204cd93b42e58338aeb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fffd4c4701ad55c6df27cdee0c47200"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapr__bucket.html">apr_bucket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga2fffd4c4701ad55c6df27cdee0c47200">apr_bucket_socket_make</a> (<a class="el" href="structapr__bucket.html">apr_bucket</a> *b, apr_socket_t *thissock)</td></tr>
<tr class="separator:ga2fffd4c4701ad55c6df27cdee0c47200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9ea07d5f9246e06c1bb3e76ee90cd71"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapr__bucket.html">apr_bucket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#gab9ea07d5f9246e06c1bb3e76ee90cd71">apr_bucket_pipe_create</a> (apr_file_t *thispipe, <a class="el" href="group___a_p_r___util___bucket___brigades.html#ga9a30babfeb6e290db124d8f9b69e49e4">apr_bucket_alloc_t</a> *list)</td></tr>
<tr class="separator:gab9ea07d5f9246e06c1bb3e76ee90cd71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7b4daa1318226beda4bf0eead2f5582"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapr__bucket.html">apr_bucket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#gae7b4daa1318226beda4bf0eead2f5582">apr_bucket_pipe_make</a> (<a class="el" href="structapr__bucket.html">apr_bucket</a> *b, apr_file_t *thispipe)</td></tr>
<tr class="separator:gae7b4daa1318226beda4bf0eead2f5582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga421f96e8e9387a9c27fe010ebdee0202"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapr__bucket.html">apr_bucket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga421f96e8e9387a9c27fe010ebdee0202">apr_bucket_file_create</a> (apr_file_t *fd, apr_off_t offset, apr_size_t len, apr_pool_t *p, <a class="el" href="group___a_p_r___util___bucket___brigades.html#ga9a30babfeb6e290db124d8f9b69e49e4">apr_bucket_alloc_t</a> *list)</td></tr>
<tr class="separator:ga421f96e8e9387a9c27fe010ebdee0202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb716dea400092f2f8c84a3f0f6d3a10"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structapr__bucket.html">apr_bucket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#gacb716dea400092f2f8c84a3f0f6d3a10">apr_bucket_file_make</a> (<a class="el" href="structapr__bucket.html">apr_bucket</a> *b, apr_file_t *fd, apr_off_t offset, apr_size_t len, apr_pool_t *p)</td></tr>
<tr class="separator:gacb716dea400092f2f8c84a3f0f6d3a10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab18ee46f66634c35ad79b6a74559cbb8"><td class="memItemLeft" align="right" valign="top">apr_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#gab18ee46f66634c35ad79b6a74559cbb8">apr_bucket_file_enable_mmap</a> (<a class="el" href="structapr__bucket.html">apr_bucket</a> *b, int enabled)</td></tr>
<tr class="separator:gab18ee46f66634c35ad79b6a74559cbb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gaecc113cfcc7751dfe70876437a2f51d7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structapr__bucket__type__t.html">apr_bucket_type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#gaecc113cfcc7751dfe70876437a2f51d7">apr_bucket_type_flush</a></td></tr>
<tr class="separator:gaecc113cfcc7751dfe70876437a2f51d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga829cac9b4843b85a902ddd64dffbfb12"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structapr__bucket__type__t.html">apr_bucket_type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga829cac9b4843b85a902ddd64dffbfb12">apr_bucket_type_eos</a></td></tr>
<tr class="separator:ga829cac9b4843b85a902ddd64dffbfb12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f17aa7e616179411a06475ec09626e9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structapr__bucket__type__t.html">apr_bucket_type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga5f17aa7e616179411a06475ec09626e9">apr_bucket_type_file</a></td></tr>
<tr class="separator:ga5f17aa7e616179411a06475ec09626e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c5608267ed7b860657f5a1c89c2f40d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structapr__bucket__type__t.html">apr_bucket_type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga2c5608267ed7b860657f5a1c89c2f40d">apr_bucket_type_heap</a></td></tr>
<tr class="separator:ga2c5608267ed7b860657f5a1c89c2f40d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63f9ce8e4d6e796921aad14a218a3b23"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structapr__bucket__type__t.html">apr_bucket_type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga63f9ce8e4d6e796921aad14a218a3b23">apr_bucket_type_mmap</a></td></tr>
<tr class="separator:ga63f9ce8e4d6e796921aad14a218a3b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87bace819fdbf07c12497a8289b3567b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structapr__bucket__type__t.html">apr_bucket_type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga87bace819fdbf07c12497a8289b3567b">apr_bucket_type_pool</a></td></tr>
<tr class="separator:ga87bace819fdbf07c12497a8289b3567b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga334a875abb2908364a40abbfa80c401f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structapr__bucket__type__t.html">apr_bucket_type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga334a875abb2908364a40abbfa80c401f">apr_bucket_type_pipe</a></td></tr>
<tr class="separator:ga334a875abb2908364a40abbfa80c401f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga391ac24b2c85969e8efa504588b364bb"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structapr__bucket__type__t.html">apr_bucket_type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga391ac24b2c85969e8efa504588b364bb">apr_bucket_type_immortal</a></td></tr>
<tr class="separator:ga391ac24b2c85969e8efa504588b364bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1692ced61c1966e67adc05ec2a69ce9b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structapr__bucket__type__t.html">apr_bucket_type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga1692ced61c1966e67adc05ec2a69ce9b">apr_bucket_type_transient</a></td></tr>
<tr class="separator:ga1692ced61c1966e67adc05ec2a69ce9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6d9978cc10895bdf0a4686728822a84"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structapr__bucket__type__t.html">apr_bucket_type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___a_p_r___util___bucket___brigades.html#gaa6d9978cc10895bdf0a4686728822a84">apr_bucket_type_socket</a></td></tr>
<tr class="separator:gaa6d9978cc10895bdf0a4686728822a84"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="gae1dfe8bf117d10e7dc5b8e0c08f0ebb2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APR_BRIGADE_CHECK_CONSISTENCY</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>checks the ring pointers in a bucket brigade for consistency. an abort() will be triggered if any inconsistencies are found. note: this is a no-op unless APR_BUCKET_DEBUG is defined. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>The brigade </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7cecbc89be912ce9ab24c889eb8f955b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APR_BRIGADE_CONCAT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> {                    \</div>
<div class="line">        APR_RING_CONCAT(&amp;(a)-&gt;list, &amp;(b)-&gt;list, <a class="code" href="structapr__bucket.html">apr_bucket</a>, link);  <a class="code" href="group___a_p_r___util___bucket___brigades.html#gae1dfe8bf117d10e7dc5b8e0c08f0ebb2">\</a></div>
<div class="line"><a class="code" href="group___a_p_r___util___bucket___brigades.html#gae1dfe8bf117d10e7dc5b8e0c08f0ebb2">        APR_BRIGADE_CHECK_CONSISTENCY</a>((a));             \</div>
<div class="line">    } <span class="keywordflow">while</span> (0)</div>
<div class="ttc" id="group___a_p_r___util___bucket___brigades_html_gae1dfe8bf117d10e7dc5b8e0c08f0ebb2"><div class="ttname"><a href="group___a_p_r___util___bucket___brigades.html#gae1dfe8bf117d10e7dc5b8e0c08f0ebb2">APR_BRIGADE_CHECK_CONSISTENCY</a></div><div class="ttdeci">#define APR_BRIGADE_CHECK_CONSISTENCY(b)</div><div class="ttdef"><b>Definition:</b> apr_buckets.h:304</div></div>
<div class="ttc" id="structapr__bucket_html"><div class="ttname"><a href="structapr__bucket.html">apr_bucket</a></div><div class="ttdef"><b>Definition:</b> apr_buckets.h:224</div></div>
</div><!-- fragment --><p>Concatenate brigade b onto the end of brigade a, leaving brigade b empty </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first brigade </td></tr>
    <tr><td class="paramname">b</td><td>The second brigade </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga836f61da6cce15074eff257ce4b6fc0f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APR_BRIGADE_EMPTY</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b</td><td>)</td>
          <td>&#160;&#160;&#160;APR_RING_EMPTY(&amp;(b)-&gt;list, <a class="el" href="structapr__bucket.html">apr_bucket</a>, link)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine if the bucket brigade is empty </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>The brigade to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true or false </dd></dl>

</div>
</div>
<a class="anchor" id="gab5826a11eb6ba90786a94282f806c230"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APR_BRIGADE_FIRST</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b</td><td>)</td>
          <td>&#160;&#160;&#160;APR_RING_FIRST(&amp;(b)-&gt;list)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the first bucket in a brigade </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>The brigade to query </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first bucket in the brigade </dd></dl>

</div>
</div>
<a class="anchor" id="ga6dc39d8757e18941a6fb069b0c18fbd3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APR_BRIGADE_INSERT_HEAD</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">e&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> {                <a class="code" href="group___a_p_r___util___bucket___brigades.html#gaa17a456120961b1c5af0525f4900a457">\</a></div>
<div class="line"><a class="code" href="group___a_p_r___util___bucket___brigades.html#gaa17a456120961b1c5af0525f4900a457">	apr_bucket</a> *ap__b = (e);                                        \</div>
<div class="line">    APR_RING_INSERT_HEAD(&amp;(b)-&gt;list, ap__b, <a class="code" href="structapr__bucket.html">apr_bucket</a>, link);  <a class="code" href="group___a_p_r___util___bucket___brigades.html#gae1dfe8bf117d10e7dc5b8e0c08f0ebb2">\</a></div>
<div class="line"><a class="code" href="group___a_p_r___util___bucket___brigades.html#gae1dfe8bf117d10e7dc5b8e0c08f0ebb2">        APR_BRIGADE_CHECK_CONSISTENCY</a>((b));             \</div>
<div class="line">    } <span class="keywordflow">while</span> (0)</div>
<div class="ttc" id="group___a_p_r___util___bucket___brigades_html_gae1dfe8bf117d10e7dc5b8e0c08f0ebb2"><div class="ttname"><a href="group___a_p_r___util___bucket___brigades.html#gae1dfe8bf117d10e7dc5b8e0c08f0ebb2">APR_BRIGADE_CHECK_CONSISTENCY</a></div><div class="ttdeci">#define APR_BRIGADE_CHECK_CONSISTENCY(b)</div><div class="ttdef"><b>Definition:</b> apr_buckets.h:304</div></div>
<div class="ttc" id="structapr__bucket_html"><div class="ttname"><a href="structapr__bucket.html">apr_bucket</a></div><div class="ttdef"><b>Definition:</b> apr_buckets.h:224</div></div>
<div class="ttc" id="group___a_p_r___util___bucket___brigades_html_gaa17a456120961b1c5af0525f4900a457"><div class="ttname"><a href="group___a_p_r___util___bucket___brigades.html#gaa17a456120961b1c5af0525f4900a457">apr_bucket</a></div><div class="ttdeci">struct apr_bucket apr_bucket</div><div class="ttdef"><b>Definition:</b> apr_buckets.h:121</div></div>
</div><!-- fragment --><p>Insert a single bucket at the front of a brigade </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>The brigade to add to </td></tr>
    <tr><td class="paramname">e</td><td>The bucket to insert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5447595f8374296c5ffe208db39b2f5d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APR_BRIGADE_INSERT_TAIL</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">e&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> {                <a class="code" href="group___a_p_r___util___bucket___brigades.html#gaa17a456120961b1c5af0525f4900a457">\</a></div>
<div class="line"><a class="code" href="group___a_p_r___util___bucket___brigades.html#gaa17a456120961b1c5af0525f4900a457">	apr_bucket</a> *ap__b = (e);                   \</div>
<div class="line">    APR_RING_INSERT_TAIL(&amp;(b)-&gt;list, ap__b, <a class="code" href="structapr__bucket.html">apr_bucket</a>, link);  <a class="code" href="group___a_p_r___util___bucket___brigades.html#gae1dfe8bf117d10e7dc5b8e0c08f0ebb2">\</a></div>
<div class="line"><a class="code" href="group___a_p_r___util___bucket___brigades.html#gae1dfe8bf117d10e7dc5b8e0c08f0ebb2">        APR_BRIGADE_CHECK_CONSISTENCY</a>((b));             \</div>
<div class="line">    } <span class="keywordflow">while</span> (0)</div>
<div class="ttc" id="group___a_p_r___util___bucket___brigades_html_gae1dfe8bf117d10e7dc5b8e0c08f0ebb2"><div class="ttname"><a href="group___a_p_r___util___bucket___brigades.html#gae1dfe8bf117d10e7dc5b8e0c08f0ebb2">APR_BRIGADE_CHECK_CONSISTENCY</a></div><div class="ttdeci">#define APR_BRIGADE_CHECK_CONSISTENCY(b)</div><div class="ttdef"><b>Definition:</b> apr_buckets.h:304</div></div>
<div class="ttc" id="structapr__bucket_html"><div class="ttname"><a href="structapr__bucket.html">apr_bucket</a></div><div class="ttdef"><b>Definition:</b> apr_buckets.h:224</div></div>
<div class="ttc" id="group___a_p_r___util___bucket___brigades_html_gaa17a456120961b1c5af0525f4900a457"><div class="ttname"><a href="group___a_p_r___util___bucket___brigades.html#gaa17a456120961b1c5af0525f4900a457">apr_bucket</a></div><div class="ttdeci">struct apr_bucket apr_bucket</div><div class="ttdef"><b>Definition:</b> apr_buckets.h:121</div></div>
</div><!-- fragment --><p>Insert a single bucket at the end of a brigade </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>The brigade to add to </td></tr>
    <tr><td class="paramname">e</td><td>The bucket to insert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga40e0ef2a904aa519ca9d63288dee0b4d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APR_BRIGADE_LAST</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b</td><td>)</td>
          <td>&#160;&#160;&#160;APR_RING_LAST(&amp;(b)-&gt;list)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the last bucket in a brigade </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>The brigade to query </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The last bucket in the brigade </dd></dl>

</div>
</div>
<a class="anchor" id="ga52ba212f76507a79ccae213875150ad1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APR_BRIGADE_PREPEND</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> {                    \</div>
<div class="line">        APR_RING_PREPEND(&amp;(a)-&gt;list, &amp;(b)-&gt;list, <a class="code" href="structapr__bucket.html">apr_bucket</a>, link); <a class="code" href="group___a_p_r___util___bucket___brigades.html#gae1dfe8bf117d10e7dc5b8e0c08f0ebb2">\</a></div>
<div class="line"><a class="code" href="group___a_p_r___util___bucket___brigades.html#gae1dfe8bf117d10e7dc5b8e0c08f0ebb2">        APR_BRIGADE_CHECK_CONSISTENCY</a>((a));             \</div>
<div class="line">    } <span class="keywordflow">while</span> (0)</div>
<div class="ttc" id="group___a_p_r___util___bucket___brigades_html_gae1dfe8bf117d10e7dc5b8e0c08f0ebb2"><div class="ttname"><a href="group___a_p_r___util___bucket___brigades.html#gae1dfe8bf117d10e7dc5b8e0c08f0ebb2">APR_BRIGADE_CHECK_CONSISTENCY</a></div><div class="ttdeci">#define APR_BRIGADE_CHECK_CONSISTENCY(b)</div><div class="ttdef"><b>Definition:</b> apr_buckets.h:304</div></div>
<div class="ttc" id="structapr__bucket_html"><div class="ttname"><a href="structapr__bucket.html">apr_bucket</a></div><div class="ttdef"><b>Definition:</b> apr_buckets.h:224</div></div>
</div><!-- fragment --><p>Prepend brigade b onto the beginning of brigade a, leaving brigade b empty </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first brigade </td></tr>
    <tr><td class="paramname">b</td><td>The second brigade </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga858da66dccab1e063415678bb115788a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APR_BRIGADE_SENTINEL</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b</td><td>)</td>
          <td>&#160;&#160;&#160;APR_RING_SENTINEL(&amp;(b)-&gt;list, <a class="el" href="structapr__bucket.html">apr_bucket</a>, link)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wrappers around the RING macros to reduce the verbosity of the code that handles bucket brigades. The magic pointer value that indicates the head of the brigade </p>
<dl class="section remark"><dt>Remarks</dt><dd>This is used to find the beginning and end of the brigade, eg: <pre>
     while (e != <a class="el" href="group___a_p_r___util___bucket___brigades.html#ga858da66dccab1e063415678bb115788a">APR_BRIGADE_SENTINEL(b)</a>) {
         ...
         e = <a class="el" href="group___a_p_r___util___bucket___brigades.html#ga7171f690b203d548a5b6ae0b079068d8">APR_BUCKET_NEXT(e)</a>;
     }
</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>The brigade </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The magic pointer value </dd></dl>

</div>
</div>
<a class="anchor" id="gae3ccf4c383c9e7fea28354cc8e029626"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APR_BUCKET_ALLOC_SIZE&#160;&#160;&#160;APR_ALIGN_DEFAULT(2*sizeof(<a class="el" href="unionapr__bucket__structs.html">apr_bucket_structs</a>))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The amount that <a class="el" href="group___a_p_r___util___bucket___brigades.html#gae47c2235a3740432f4a0990fccfe4102">apr_bucket_alloc()</a> should allocate in the common case. Note: this is twice as big as <a class="el" href="unionapr__bucket__structs.html">apr_bucket_structs</a> to allow breathing room for third-party bucket types. </p>

</div>
</div>
<a class="anchor" id="ga82bf404af30875135c65e2c13ad035e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APR_BUCKET_BUFF_SIZE&#160;&#160;&#160;8000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>default bucket buffer size - 8KB minus room for memory allocator headers </p>

</div>
</div>
<a class="anchor" id="gaedaeb3fbe71aac408377471b8a54dc08"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APR_BUCKET_CHECK_CONSISTENCY</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">e</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>checks the brigade a bucket is in for ring consistency. an abort() will be triggered if any inconsistencies are found. note: this is a no-op unless APR_BUCKET_DEBUG is defined. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The bucket </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab33cc08b7f064d06397f312e427279c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define apr_bucket_copy</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">e, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">c&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(e)-&gt;type-&gt;copy(e, c)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy a bucket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The bucket to copy </td></tr>
    <tr><td class="paramname">c</td><td>Returns a pointer to the new bucket </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8925c02a7f95e8c1c3986294d4678797"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define apr_bucket_delete</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">e</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> {                    <a class="code" href="group___a_p_r___util___bucket___brigades.html#ga2c46a1b717a87b68bd98b425e0c64977">\</a></div>
<div class="line"><a class="code" href="group___a_p_r___util___bucket___brigades.html#ga2c46a1b717a87b68bd98b425e0c64977">        APR_BUCKET_REMOVE</a>(e);                       <a class="code" href="group___a_p_r___util___bucket___brigades.html#gafc0dae1e90a798284ed777a0c9e90ec6">\</a></div>
<div class="line"><a class="code" href="group___a_p_r___util___bucket___brigades.html#gafc0dae1e90a798284ed777a0c9e90ec6">        apr_bucket_destroy</a>(e);                      \</div>
<div class="line">    } <span class="keywordflow">while</span> (0)</div>
<div class="ttc" id="group___a_p_r___util___bucket___brigades_html_ga2c46a1b717a87b68bd98b425e0c64977"><div class="ttname"><a href="group___a_p_r___util___bucket___brigades.html#ga2c46a1b717a87b68bd98b425e0c64977">APR_BUCKET_REMOVE</a></div><div class="ttdeci">#define APR_BUCKET_REMOVE(e)</div><div class="ttdef"><b>Definition:</b> apr_buckets.h:434</div></div>
<div class="ttc" id="group___a_p_r___util___bucket___brigades_html_gafc0dae1e90a798284ed777a0c9e90ec6"><div class="ttname"><a href="group___a_p_r___util___bucket___brigades.html#gafc0dae1e90a798284ed777a0c9e90ec6">apr_bucket_destroy</a></div><div class="ttdeci">#define apr_bucket_destroy(e)</div><div class="ttdef"><b>Definition:</b> apr_buckets.h:985</div></div>
</div><!-- fragment --><p>Delete a bucket by removing it from its brigade (if any) and then destroying it. </p>
<dl class="section remark"><dt>Remarks</dt><dd>This mainly acts as an aid in avoiding code verbosity. It is the preferred exact equivalent to: <pre>
     <a class="el" href="group___a_p_r___util___bucket___brigades.html#ga2c46a1b717a87b68bd98b425e0c64977">APR_BUCKET_REMOVE(e)</a>;
     <a class="el" href="group___a_p_r___util___bucket___brigades.html#gafc0dae1e90a798284ed777a0c9e90ec6">apr_bucket_destroy(e)</a>;
</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The bucket to delete </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gafc0dae1e90a798284ed777a0c9e90ec6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define apr_bucket_destroy</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">e</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> {                    \</div>
<div class="line">        (e)-&gt;type-&gt;destroy((e)-&gt;data);                  \</div>
<div class="line">        (e)-&gt;free(e);                           \</div>
<div class="line">    } <span class="keywordflow">while</span> (0)</div>
</div><!-- fragment --><p>Free the resources used by a bucket. If multiple buckets refer to the same resource it is freed when the last one goes away. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga8925c02a7f95e8c1c3986294d4678797">apr_bucket_delete()</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The bucket to destroy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga00c2e104125f124c3a52627863432de9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APR_BUCKET_INIT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">e</td><td>)</td>
          <td>&#160;&#160;&#160;APR_RING_ELEM_INIT((e), link)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize a new bucket's prev/next pointers </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The bucket to initialize </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1f8114b7316d1fef1deb95abc8f02341"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APR_BUCKET_INSERT_AFTER</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> {                <a class="code" href="group___a_p_r___util___bucket___brigades.html#gaa17a456120961b1c5af0525f4900a457">\</a></div>
<div class="line"><a class="code" href="group___a_p_r___util___bucket___brigades.html#gaa17a456120961b1c5af0525f4900a457">	apr_bucket</a> *ap__a = (a), *ap__b = (b);             \</div>
<div class="line">    APR_RING_INSERT_AFTER(ap__a, ap__b, link);          <a class="code" href="group___a_p_r___util___bucket___brigades.html#gaedaeb3fbe71aac408377471b8a54dc08">\</a></div>
<div class="line"><a class="code" href="group___a_p_r___util___bucket___brigades.html#gaedaeb3fbe71aac408377471b8a54dc08">        APR_BUCKET_CHECK_CONSISTENCY</a>(ap__a);                \</div>
<div class="line">    } <span class="keywordflow">while</span> (0)</div>
<div class="ttc" id="group___a_p_r___util___bucket___brigades_html_gaedaeb3fbe71aac408377471b8a54dc08"><div class="ttname"><a href="group___a_p_r___util___bucket___brigades.html#gaedaeb3fbe71aac408377471b8a54dc08">APR_BUCKET_CHECK_CONSISTENCY</a></div><div class="ttdeci">#define APR_BUCKET_CHECK_CONSISTENCY(e)</div><div class="ttdef"><b>Definition:</b> apr_buckets.h:311</div></div>
<div class="ttc" id="group___a_p_r___util___bucket___brigades_html_gaa17a456120961b1c5af0525f4900a457"><div class="ttname"><a href="group___a_p_r___util___bucket___brigades.html#gaa17a456120961b1c5af0525f4900a457">apr_bucket</a></div><div class="ttdeci">struct apr_bucket apr_bucket</div><div class="ttdef"><b>Definition:</b> apr_buckets.h:121</div></div>
</div><!-- fragment --><p>Insert a single bucket after a specified bucket </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The bucket to insert after </td></tr>
    <tr><td class="paramname">b</td><td>The bucket to insert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae012adeccda754eabc42b7855bec081e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APR_BUCKET_INSERT_BEFORE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> {                <a class="code" href="group___a_p_r___util___bucket___brigades.html#gaa17a456120961b1c5af0525f4900a457">\</a></div>
<div class="line"><a class="code" href="group___a_p_r___util___bucket___brigades.html#gaa17a456120961b1c5af0525f4900a457">	apr_bucket</a> *ap__a = (a), *ap__b = (b);             \</div>
<div class="line">    APR_RING_INSERT_BEFORE(ap__a, ap__b, link);         <a class="code" href="group___a_p_r___util___bucket___brigades.html#gaedaeb3fbe71aac408377471b8a54dc08">\</a></div>
<div class="line"><a class="code" href="group___a_p_r___util___bucket___brigades.html#gaedaeb3fbe71aac408377471b8a54dc08">        APR_BUCKET_CHECK_CONSISTENCY</a>(ap__a);                \</div>
<div class="line">    } <span class="keywordflow">while</span> (0)</div>
<div class="ttc" id="group___a_p_r___util___bucket___brigades_html_gaedaeb3fbe71aac408377471b8a54dc08"><div class="ttname"><a href="group___a_p_r___util___bucket___brigades.html#gaedaeb3fbe71aac408377471b8a54dc08">APR_BUCKET_CHECK_CONSISTENCY</a></div><div class="ttdeci">#define APR_BUCKET_CHECK_CONSISTENCY(e)</div><div class="ttdef"><b>Definition:</b> apr_buckets.h:311</div></div>
<div class="ttc" id="group___a_p_r___util___bucket___brigades_html_gaa17a456120961b1c5af0525f4900a457"><div class="ttname"><a href="group___a_p_r___util___bucket___brigades.html#gaa17a456120961b1c5af0525f4900a457">apr_bucket</a></div><div class="ttdeci">struct apr_bucket apr_bucket</div><div class="ttdef"><b>Definition:</b> apr_buckets.h:121</div></div>
</div><!-- fragment --><p>Insert a single bucket before a specified bucket </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The bucket to insert before </td></tr>
    <tr><td class="paramname">b</td><td>The bucket to insert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga89b225e1c08473766eec719b985ca0d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APR_BUCKET_IS_EOS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">e</td><td>)</td>
          <td>&#160;&#160;&#160;((e)-&gt;type == &amp;<a class="el" href="group___a_p_r___util___bucket___brigades.html#ga829cac9b4843b85a902ddd64dffbfb12">apr_bucket_type_eos</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine if a bucket is an EOS bucket </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The bucket to inspect </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true or false </dd></dl>

</div>
</div>
<a class="anchor" id="ga1d54037bb6953c73d5c61f64c311d470"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APR_BUCKET_IS_FILE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">e</td><td>)</td>
          <td>&#160;&#160;&#160;((e)-&gt;type == &amp;<a class="el" href="group___a_p_r___util___bucket___brigades.html#ga5f17aa7e616179411a06475ec09626e9">apr_bucket_type_file</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine if a bucket is a FILE bucket </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The bucket to inspect </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true or false </dd></dl>

</div>
</div>
<a class="anchor" id="ga24105da0bb755a775c4b2a519d7c25f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APR_BUCKET_IS_FLUSH</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">e</td><td>)</td>
          <td>&#160;&#160;&#160;((e)-&gt;type == &amp;<a class="el" href="group___a_p_r___util___bucket___brigades.html#gaecc113cfcc7751dfe70876437a2f51d7">apr_bucket_type_flush</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine if a bucket is a FLUSH bucket </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The bucket to inspect </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true or false </dd></dl>

</div>
</div>
<a class="anchor" id="ga3dee4fbd5b4e16e5188a6cfec40b6961"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APR_BUCKET_IS_HEAP</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">e</td><td>)</td>
          <td>&#160;&#160;&#160;((e)-&gt;type == &amp;<a class="el" href="group___a_p_r___util___bucket___brigades.html#ga2c5608267ed7b860657f5a1c89c2f40d">apr_bucket_type_heap</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine if a bucket is a HEAP bucket </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The bucket to inspect </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true or false </dd></dl>

</div>
</div>
<a class="anchor" id="ga53f1188c168acf7dcfabfa1ac5a08655"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APR_BUCKET_IS_IMMORTAL</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">e</td><td>)</td>
          <td>&#160;&#160;&#160;((e)-&gt;type == &amp;<a class="el" href="group___a_p_r___util___bucket___brigades.html#ga391ac24b2c85969e8efa504588b364bb">apr_bucket_type_immortal</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine if a bucket is a IMMORTAL bucket </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The bucket to inspect </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true or false </dd></dl>

</div>
</div>
<a class="anchor" id="ga506cb29cc1ec1abeb487e01b122bd4d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APR_BUCKET_IS_METADATA</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">e</td><td>)</td>
          <td>&#160;&#160;&#160;((e)-&gt;type-&gt;is_metadata)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine if a bucket contains metadata. An empty bucket is safe to arbitrarily remove if and only if this is false. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The bucket to inspect </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true or false </dd></dl>

</div>
</div>
<a class="anchor" id="ga1693d49aeb0287e3b171c922c6b633d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APR_BUCKET_IS_MMAP</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">e</td><td>)</td>
          <td>&#160;&#160;&#160;((e)-&gt;type == &amp;<a class="el" href="group___a_p_r___util___bucket___brigades.html#ga63f9ce8e4d6e796921aad14a218a3b23">apr_bucket_type_mmap</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine if a bucket is a MMAP bucket </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The bucket to inspect </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true or false </dd></dl>

</div>
</div>
<a class="anchor" id="ga03e62d86c994d1d1cc9be3eb8b8f6ac6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APR_BUCKET_IS_PIPE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">e</td><td>)</td>
          <td>&#160;&#160;&#160;((e)-&gt;type == &amp;<a class="el" href="group___a_p_r___util___bucket___brigades.html#ga334a875abb2908364a40abbfa80c401f">apr_bucket_type_pipe</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine if a bucket is a PIPE bucket </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The bucket to inspect </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true or false </dd></dl>

</div>
</div>
<a class="anchor" id="gadbe80a9016da6a06ab414ba61d6625d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APR_BUCKET_IS_POOL</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">e</td><td>)</td>
          <td>&#160;&#160;&#160;((e)-&gt;type == &amp;<a class="el" href="group___a_p_r___util___bucket___brigades.html#ga87bace819fdbf07c12497a8289b3567b">apr_bucket_type_pool</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine if a bucket is a POOL bucket </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The bucket to inspect </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true or false </dd></dl>

</div>
</div>
<a class="anchor" id="ga4b8315b498e4eb67efde1c83bdbe8b87"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APR_BUCKET_IS_SOCKET</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">e</td><td>)</td>
          <td>&#160;&#160;&#160;((e)-&gt;type == &amp;<a class="el" href="group___a_p_r___util___bucket___brigades.html#gaa6d9978cc10895bdf0a4686728822a84">apr_bucket_type_socket</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine if a bucket is a SOCKET bucket </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The bucket to inspect </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true or false </dd></dl>

</div>
</div>
<a class="anchor" id="ga1a7e7ac5fddbab4ce189e8d3007446ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APR_BUCKET_IS_TRANSIENT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">e</td><td>)</td>
          <td>&#160;&#160;&#160;((e)-&gt;type == &amp;<a class="el" href="group___a_p_r___util___bucket___brigades.html#ga1692ced61c1966e67adc05ec2a69ce9b">apr_bucket_type_transient</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine if a bucket is a TRANSIENT bucket </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The bucket to inspect </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true or false </dd></dl>

</div>
</div>
<a class="anchor" id="ga7171f690b203d548a5b6ae0b079068d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APR_BUCKET_NEXT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">e</td><td>)</td>
          <td>&#160;&#160;&#160;APR_RING_NEXT((e), link)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the next bucket in the list </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The current bucket </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The next bucket </dd></dl>

</div>
</div>
<a class="anchor" id="gaf229fecd4174efd4d6a9774e3048ae28"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APR_BUCKET_PREV</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">e</td><td>)</td>
          <td>&#160;&#160;&#160;APR_RING_PREV((e), link)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the previous bucket in the list </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The current bucket </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The previous bucket </dd></dl>

</div>
</div>
<a class="anchor" id="gae44ae938c6c60e148430fdb098dcf28f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define apr_bucket_read</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">e, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">str, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">len, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">block&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(e)-&gt;type-&gt;read(e, str, len, block)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read some data from the bucket.</p>
<p>The apr_bucket_read function returns a convenient amount of data from the bucket provided, writing the address and length of the data to the pointers provided by the caller. The function tries as hard as possible to avoid a memory copy.</p>
<p>Buckets are expected to be a member of a brigade at the time they are read.</p>
<p>In typical application code, buckets are read in a loop, and after each bucket is read and processed, it is moved or deleted from the brigade and the next bucket read.</p>
<p>The definition of "convenient" depends on the type of bucket that is being read, and is decided by APR. In the case of memory based buckets such as heap and immortal buckets, a pointer will be returned to the location of the buffer containing the complete contents of the bucket.</p>
<p>Some buckets, such as the socket bucket, might have no concept of length. If an attempt is made to read such a bucket, the apr_bucket_read function will read a convenient amount of data from the socket. The socket bucket is magically morphed into a heap bucket containing the just-read data, and a new socket bucket is inserted just after this heap bucket.</p>
<p>To understand why apr_bucket_read might do this, consider the loop described above to read and process buckets. The current bucket is magically morphed into a heap bucket and returned to the caller. The caller processes the data, and deletes the heap bucket, moving onto the next bucket, the new socket bucket. This process repeats, giving the illusion of a bucket brigade that contains potentially infinite amounts of data. It is up to the caller to decide at what point to stop reading buckets.</p>
<p>Some buckets, such as the file bucket, might have a fixed size, but be significantly larger than is practical to store in RAM in one go. As with the socket bucket, if an attempt is made to read from a file bucket, the file bucket is magically morphed into a heap bucket containing a convenient amount of data read from the current offset in the file. During the read, the offset will be moved forward on the file, and a new file bucket will be inserted directly after the current bucket representing the remainder of the file. If the heap bucket was large enough to store the whole remainder of the file, no more file buckets are inserted, and the file bucket will disappear completely.</p>
<p>The pattern for reading buckets described above does create the illusion that the code is willing to swallow buckets that might be too large for the system to handle in one go. This however is just an illusion: APR will always ensure that large (file) or infinite (socket) buckets are broken into convenient bite sized heap buckets before data is returned to the caller.</p>
<p>There is a potential gotcha to watch for: if buckets are read in a loop, and aren't deleted after being processed, the potentially large bucket will slowly be converted into RAM resident heap buckets. If the file is larger than available RAM, an out of memory condition could be caused if the application is not careful to manage this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The bucket to read from </td></tr>
    <tr><td class="paramname">str</td><td>The location to store a pointer to the data in </td></tr>
    <tr><td class="paramname">len</td><td>The location to store the amount of data read </td></tr>
    <tr><td class="paramname">block</td><td>Whether the read function blocks </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2c46a1b717a87b68bd98b425e0c64977"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define APR_BUCKET_REMOVE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">e</td><td>)</td>
          <td>&#160;&#160;&#160;APR_RING_REMOVE((e), link)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove a bucket from its bucket brigade </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The bucket to remove </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab00941ffd472982693eb415a964de7af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define apr_bucket_setaside</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">e, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">p&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(e)-&gt;type-&gt;setaside(e,p)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Setaside data so that stack data is not destroyed on returning from the function </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The bucket to setaside </td></tr>
    <tr><td class="paramname">p</td><td>The pool to setaside into </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5bb8827a8dd1baa6ac32682e13e9d8c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define apr_bucket_split</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">e, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">point&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(e)-&gt;type-&gt;split(e, point)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Split one bucket in two at the point provided.</p>
<p>Once split, the original bucket becomes the first of the two new buckets.</p>
<p>(It is assumed that the bucket is a member of a brigade when this function is called). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The bucket to split </td></tr>
    <tr><td class="paramname">point</td><td>The offset to split the bucket at </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="gacdf6dc9d4c81c64834e5e509281f7f16"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef apr_status_t(* apr_brigade_flush)(<a class="el" href="structapr__bucket__brigade.html">apr_bucket_brigade</a> *bb, void *ctx)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function called when a brigade should be flushed </p>

</div>
</div>
<a class="anchor" id="gaa17a456120961b1c5af0525f4900a457"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structapr__bucket.html">apr_bucket</a> <a class="el" href="structapr__bucket.html">apr_bucket</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structapr__bucket.html">apr_bucket</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga9a30babfeb6e290db124d8f9b69e49e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="group___a_p_r___util___bucket___brigades.html#ga9a30babfeb6e290db124d8f9b69e49e4">apr_bucket_alloc_t</a> <a class="el" href="group___a_p_r___util___bucket___brigades.html#ga9a30babfeb6e290db124d8f9b69e49e4">apr_bucket_alloc_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga9a30babfeb6e290db124d8f9b69e49e4">apr_bucket_alloc_t</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga9f50254e85c7aad79ca289a0ba069025"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structapr__bucket__brigade.html">apr_bucket_brigade</a> <a class="el" href="structapr__bucket__brigade.html">apr_bucket_brigade</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The one-sentence buzzword-laden overview: Bucket brigades represent a complex data stream that can be passed through a layered IO system without unnecessary copying. A longer overview follows...</p>
<p>A bucket brigade is a doubly linked list (ring) of buckets, so we aren't limited to inserting at the front and removing at the end. Buckets are only passed around as members of a brigade, although singleton buckets can occur for short periods of time.</p>
<p>Buckets are data stores of various types. They can refer to data in memory, or part of a file or mmap area, or the output of a process, etc. Buckets also have some type-dependent accessor functions: read, split, copy, setaside, and destroy.</p>
<p>read returns the address and size of the data in the bucket. If the data isn't in memory then it is read in and the bucket changes type so that it can refer to the new location of the data. If all the data doesn't fit in the bucket then a new bucket is inserted into the brigade to hold the rest of it.</p>
<p>split divides the data in a bucket into two regions. After a split the original bucket refers to the first part of the data and a new bucket inserted into the brigade after the original bucket refers to the second part of the data. Reference counts are maintained as necessary.</p>
<p>setaside ensures that the data in the bucket has a long enough lifetime. Sometimes it is convenient to create a bucket referring to data on the stack in the expectation that it will be consumed (output to the network) before the stack is unwound. If that expectation turns out not to be valid, the setaside function is called to move the data somewhere safer.</p>
<p>copy makes a duplicate of the bucket structure as long as it's possible to have multiple references to a single copy of the data itself. Not all bucket types can be copied.</p>
<p>destroy maintains the reference counts on the resources used by a bucket and frees them if necessary.</p>
<p>Note: all of the above functions have wrapper macros (<a class="el" href="group___a_p_r___util___bucket___brigades.html#gae44ae938c6c60e148430fdb098dcf28f">apr_bucket_read()</a>, <a class="el" href="group___a_p_r___util___bucket___brigades.html#gafc0dae1e90a798284ed777a0c9e90ec6">apr_bucket_destroy()</a>, etc), and those macros should be used rather than using the function pointers directly.</p>
<p>To write a bucket brigade, they are first made into an iovec, so that we don't write too little data at one time. Currently we ignore compacting the buckets into as few buckets as possible, but if we really want good performance, then we need to compact the buckets before we convert to an iovec, or possibly while we are converting to an iovec.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structapr__bucket__brigade.html">apr_bucket_brigade</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga1a786f7edac4d7a2c212f0fe74457b3d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structapr__bucket__file.html">apr_bucket_file</a> <a class="el" href="structapr__bucket__file.html">apr_bucket_file</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structapr__bucket__file.html">apr_bucket_file</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaede6e77d621d0f3f7d2685d489d01283"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structapr__bucket__heap.html">apr_bucket_heap</a> <a class="el" href="structapr__bucket__heap.html">apr_bucket_heap</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structapr__bucket__heap.html">apr_bucket_heap</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga27ede7c3a29627c7d184dc7cfbc4f767"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structapr__bucket__mmap.html">apr_bucket_mmap</a> <a class="el" href="structapr__bucket__mmap.html">apr_bucket_mmap</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structapr__bucket__mmap.html">apr_bucket_mmap</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga211e00d871029de148116cd24b070aed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structapr__bucket__pool.html">apr_bucket_pool</a> <a class="el" href="structapr__bucket__pool.html">apr_bucket_pool</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structapr__bucket__pool.html">apr_bucket_pool</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga785fd3402961b30315975b0c87c87706"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structapr__bucket__refcount.html">apr_bucket_refcount</a> <a class="el" href="structapr__bucket__refcount.html">apr_bucket_refcount</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structapr__bucket__refcount.html">apr_bucket_refcount</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga3c0929c971f94de4521fb0fea6fd3209"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef union <a class="el" href="unionapr__bucket__structs.html">apr_bucket_structs</a> <a class="el" href="unionapr__bucket__structs.html">apr_bucket_structs</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="unionapr__bucket__structs.html">apr_bucket_structs</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga4a152aaf7d851c81af73b7e84dc1a8a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structapr__bucket__type__t.html">apr_bucket_type_t</a> <a class="el" href="structapr__bucket__type__t.html">apr_bucket_type_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structapr__bucket__type__t.html">apr_bucket_type_t</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ga756973fb6392bd1026c3d96b4519776d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___a_p_r___util___bucket___brigades.html#ga756973fb6392bd1026c3d96b4519776d">apr_read_type_e</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determines how a bucket or brigade should be read </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="gga756973fb6392bd1026c3d96b4519776da2d983f5b7fd996434e0dded171c261d8"></a>APR_BLOCK_READ</em>&nbsp;</td><td class="fielddoc">
<p>block until data becomes available </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga756973fb6392bd1026c3d96b4519776da42b97663ca71fbbf2e2af7c8192e5dd8"></a>APR_NONBLOCK_READ</em>&nbsp;</td><td class="fielddoc">
<p>return immediately if no data is available </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gafd6a8378a15e8b42a57a5923a03de7f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">apr_status_t apr_brigade_cleanup </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>empty out an entire bucket brigade. This includes destroying all of the buckets within the bucket brigade's bucket list. This is similar to <a class="el" href="group___a_p_r___util___bucket___brigades.html#ga2eba1e262dece0d4444ddd25ae7b250a">apr_brigade_destroy()</a>, except that it does not deregister the brigade's pool cleanup function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The bucket brigade to clean up </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Generally, you should use <a class="el" href="group___a_p_r___util___bucket___brigades.html#ga2eba1e262dece0d4444ddd25ae7b250a">apr_brigade_destroy()</a>. This function can be useful in situations where you have a single brigade that you wish to reuse many times by destroying all of the buckets in the brigade and putting new buckets into it later. </dd></dl>

</div>
</div>
<a class="anchor" id="gaeb422371006699c68f0ed3b496cc12a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapr__bucket__brigade.html">apr_bucket_brigade</a>* apr_brigade_create </td>
          <td>(</td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga9a30babfeb6e290db124d8f9b69e49e4">apr_bucket_alloc_t</a> *&#160;</td>
          <td class="paramname"><em>list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new bucket brigade. The bucket brigade is originally empty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>The pool to associate with the brigade. Data is not allocated out of the pool, but a cleanup is registered. </td></tr>
    <tr><td class="paramname">list</td><td>The bucket allocator to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The empty bucket brigade </dd></dl>

</div>
</div>
<a class="anchor" id="ga2eba1e262dece0d4444ddd25ae7b250a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">apr_status_t apr_brigade_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapr__bucket__brigade.html">apr_bucket_brigade</a> *&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>destroy an entire bucket brigade. This includes destroying all of the buckets within the bucket brigade's bucket list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>The bucket brigade to destroy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga301aeb943e68ef4b99c1ae6a18dcf78e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">apr_status_t apr_brigade_flatten </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapr__bucket__brigade.html">apr_bucket_brigade</a> *&#160;</td>
          <td class="paramname"><em>bb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t *&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Take a bucket brigade and store the data in a flat char* </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bb</td><td>The bucket brigade to create the char* from </td></tr>
    <tr><td class="paramname">c</td><td>The char* to write into </td></tr>
    <tr><td class="paramname">len</td><td>The maximum length of the char array. On return, it is the actual length of the char array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7c4981f7050333a181e440e753c20555"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapr__bucket.html">apr_bucket</a>* apr_brigade_insert_file </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapr__bucket__brigade.html">apr_bucket_brigade</a> *&#160;</td>
          <td class="paramname"><em>bb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_file_t *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_off_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_off_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Utility function to insert a file (or a segment of a file) onto the end of the brigade. The file is split into multiple buckets if it is larger than the maximum size which can be represented by a single bucket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bb</td><td>the brigade to insert into </td></tr>
    <tr><td class="paramname">f</td><td>the file to insert </td></tr>
    <tr><td class="paramname">start</td><td>the offset of the start of the segment </td></tr>
    <tr><td class="paramname">len</td><td>the length of the segment of the file to insert </td></tr>
    <tr><td class="paramname">p</td><td>pool from which file buckets are allocated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the last bucket inserted </dd></dl>

</div>
</div>
<a class="anchor" id="ga65075839e31fd85e2c80717f4e9e0461"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">apr_status_t apr_brigade_length </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapr__bucket__brigade.html">apr_bucket_brigade</a> *&#160;</td>
          <td class="paramname"><em>bb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>read_all</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_off_t *&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the total length of the brigade. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bb</td><td>The brigade to compute the length of </td></tr>
    <tr><td class="paramname">read_all</td><td>Read unknown-length buckets to force a size </td></tr>
    <tr><td class="paramname">length</td><td>Returns the length of the brigade (up to the end, or up to a bucket read error), or -1 if the brigade has buckets of indeterminate length and read_all is 0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4b2f22ba70ac9f65788014c61d4f5b76"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">apr_status_t apr_brigade_partition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapr__bucket__brigade.html">apr_bucket_brigade</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_off_t&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapr__bucket.html">apr_bucket</a> **&#160;</td>
          <td class="paramname"><em>after_point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Partition a bucket brigade at a given offset (in bytes from the start of the brigade). This is useful whenever a filter wants to use known ranges of bytes from the brigade; the ranges can even overlap. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>The brigade to partition </td></tr>
    <tr><td class="paramname">point</td><td>The offset at which to partition the brigade </td></tr>
    <tr><td class="paramname">after_point</td><td>Returns a pointer to the first bucket after the partition </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>APR_SUCCESS on success, APR_INCOMPLETE if the contents of the brigade were shorter than <em>point</em>, or an error code. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>if APR_INCOMPLETE is returned, <em>after_point</em> will be set to the brigade sentinel. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa5da970af09d1a87e020db054f2d1c94"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">apr_status_t apr_brigade_pflatten </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapr__bucket__brigade.html">apr_bucket_brigade</a> *&#160;</td>
          <td class="paramname"><em>bb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t *&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a pool-allocated string representing a flat bucket brigade </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bb</td><td>The bucket brigade to create the char array from </td></tr>
    <tr><td class="paramname">c</td><td>On return, the allocated char array </td></tr>
    <tr><td class="paramname">len</td><td>On return, the length of the char array. </td></tr>
    <tr><td class="paramname">pool</td><td>The pool to allocate the string from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4120ba3834c545db3b9229d858e33b47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">apr_status_t apr_brigade_printf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapr__bucket__brigade.html">apr_bucket_brigade</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_p_r___util___bucket___brigades.html#gacdf6dc9d4c81c64834e5e509281f7f16">apr_brigade_flush</a>&#160;</td>
          <td class="paramname"><em>flush</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Evaluate a printf and put the resulting string at the end of the bucket brigade. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>The brigade to write to </td></tr>
    <tr><td class="paramname">flush</td><td>The flush function to use if the brigade is full </td></tr>
    <tr><td class="paramname">ctx</td><td>The structure to pass to the flush function </td></tr>
    <tr><td class="paramname">fmt</td><td>The format of the string to write </td></tr>
    <tr><td class="paramname">...</td><td>The arguments to fill out the format </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>APR_SUCCESS or error code </dd></dl>

</div>
</div>
<a class="anchor" id="ga362999cb255297fd0fd433f03236302d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">apr_status_t apr_brigade_putc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapr__bucket__brigade.html">apr_bucket_brigade</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_p_r___util___bucket___brigades.html#gacdf6dc9d4c81c64834e5e509281f7f16">apr_brigade_flush</a>&#160;</td>
          <td class="paramname"><em>flush</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function writes a character into a bucket brigade. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>The bucket brigade to add to </td></tr>
    <tr><td class="paramname">flush</td><td>The flush function to use if the brigade is full </td></tr>
    <tr><td class="paramname">ctx</td><td>The structure to pass to the flush function </td></tr>
    <tr><td class="paramname">c</td><td>The character to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>APR_SUCCESS or error code </dd></dl>

</div>
</div>
<a class="anchor" id="ga2d1fed26db94e3006223098737a06f5a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">apr_status_t apr_brigade_puts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapr__bucket__brigade.html">apr_bucket_brigade</a> *&#160;</td>
          <td class="paramname"><em>bb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_p_r___util___bucket___brigades.html#gacdf6dc9d4c81c64834e5e509281f7f16">apr_brigade_flush</a>&#160;</td>
          <td class="paramname"><em>flush</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function writes a string into a bucket brigade. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bb</td><td>The bucket brigade to add to </td></tr>
    <tr><td class="paramname">flush</td><td>The flush function to use if the brigade is full </td></tr>
    <tr><td class="paramname">ctx</td><td>The structure to pass to the flush function </td></tr>
    <tr><td class="paramname">str</td><td>The string to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>APR_SUCCESS or error code </dd></dl>

</div>
</div>
<a class="anchor" id="ga1f27949d92196cbf150b7d6256cbf4b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">apr_status_t apr_brigade_putstrs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapr__bucket__brigade.html">apr_bucket_brigade</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_p_r___util___bucket___brigades.html#gacdf6dc9d4c81c64834e5e509281f7f16">apr_brigade_flush</a>&#160;</td>
          <td class="paramname"><em>flush</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function writes an unspecified number of strings into a bucket brigade. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>The bucket brigade to add to </td></tr>
    <tr><td class="paramname">flush</td><td>The flush function to use if the brigade is full </td></tr>
    <tr><td class="paramname">ctx</td><td>The structure to pass to the flush function </td></tr>
    <tr><td class="paramname">...</td><td>The strings to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>APR_SUCCESS or error code </dd></dl>

</div>
</div>
<a class="anchor" id="gacaf2929f951920a464e170baf2b4c345"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapr__bucket__brigade.html">apr_bucket_brigade</a>* apr_brigade_split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapr__bucket__brigade.html">apr_bucket_brigade</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapr__bucket.html">apr_bucket</a> *&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new bucket brigade and move the buckets from the tail end of an existing brigade into the new brigade. Buckets from <em>e</em> to the last bucket (inclusively) of brigade <em>b</em> are moved from <em>b</em> to the returned brigade. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>The brigade to split </td></tr>
    <tr><td class="paramname">e</td><td>The first bucket to move </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new brigade </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Note that this function always allocates a new brigade so memory consumption should be carefully considered. </dd></dl>

</div>
</div>
<a class="anchor" id="ga36448fa89ab3239fd46591fbc82624e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapr__bucket__brigade.html">apr_bucket_brigade</a>* apr_brigade_split_ex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapr__bucket__brigade.html">apr_bucket_brigade</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapr__bucket.html">apr_bucket</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapr__bucket__brigade.html">apr_bucket_brigade</a> *&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Move the buckets from the tail end of the existing brigade <em>b</em> into the brigade <em>a</em>. If <em>a</em> is NULL a new brigade is created. Buckets from <em>e</em> to the last bucket (inclusively) of brigade <em>b</em> are moved from <em>b</em> to the returned brigade <em>a</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>The brigade to split </td></tr>
    <tr><td class="paramname">e</td><td>The first bucket to move </td></tr>
    <tr><td class="paramname">a</td><td>The brigade which should be used for the result or NULL if a new brigade should be created. The brigade <em>a</em> will be cleared if it is not empty. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The brigade supplied in <em>a</em> or a new one if <em>a</em> was NULL. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Note that this function allocates a new brigade if <em>a</em> is NULL so memory consumption should be carefully considered. </dd></dl>

</div>
</div>
<a class="anchor" id="ga257dece60dbdc910bc09e1fc0d7db622"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">apr_status_t apr_brigade_split_line </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapr__bucket__brigade.html">apr_bucket_brigade</a> *&#160;</td>
          <td class="paramname"><em>bbOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapr__bucket__brigade.html">apr_bucket_brigade</a> *&#160;</td>
          <td class="paramname"><em>bbIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga756973fb6392bd1026c3d96b4519776d">apr_read_type_e</a>&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_off_t&#160;</td>
          <td class="paramname"><em>maxbytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Split a brigade to represent one LF line. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bbOut</td><td>The bucket brigade that will have the LF line appended to. </td></tr>
    <tr><td class="paramname">bbIn</td><td>The input bucket brigade to search for a LF-line. </td></tr>
    <tr><td class="paramname">block</td><td>The blocking mode to be used to split the line. </td></tr>
    <tr><td class="paramname">maxbytes</td><td>The maximum bytes to read. If this many bytes are seen without a LF, the brigade will contain a partial line. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga904bdc4a9a9c800d2d2b20b4ddefa6f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">apr_status_t apr_brigade_to_iovec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapr__bucket__brigade.html">apr_bucket_brigade</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct iovec *&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>nvec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create an iovec of the elements in a bucket_brigade... return number of elements used. This is useful for writing to a file or to the network efficiently. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>The bucket brigade to create the iovec from </td></tr>
    <tr><td class="paramname">vec</td><td>The iovec to create </td></tr>
    <tr><td class="paramname">nvec</td><td>The number of elements in the iovec. On return, it is the number of iovec elements actually filled out. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9e1af8c10946264e1bb37a3f56e4bfd8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">apr_status_t apr_brigade_vprintf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapr__bucket__brigade.html">apr_bucket_brigade</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_p_r___util___bucket___brigades.html#gacdf6dc9d4c81c64834e5e509281f7f16">apr_brigade_flush</a>&#160;</td>
          <td class="paramname"><em>flush</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>va</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Evaluate a printf and put the resulting string at the end of the bucket brigade. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>The brigade to write to </td></tr>
    <tr><td class="paramname">flush</td><td>The flush function to use if the brigade is full </td></tr>
    <tr><td class="paramname">ctx</td><td>The structure to pass to the flush function </td></tr>
    <tr><td class="paramname">fmt</td><td>The format of the string to write </td></tr>
    <tr><td class="paramname">va</td><td>The arguments to fill out the format </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>APR_SUCCESS or error code </dd></dl>

</div>
</div>
<a class="anchor" id="ga382871c1aec5cf9fbbcf19d67cff6b43"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">apr_status_t apr_brigade_vputstrs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapr__bucket__brigade.html">apr_bucket_brigade</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_p_r___util___bucket___brigades.html#gacdf6dc9d4c81c64834e5e509281f7f16">apr_brigade_flush</a>&#160;</td>
          <td class="paramname"><em>flush</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>va</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function writes a list of strings into a bucket brigade. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>The bucket brigade to add to </td></tr>
    <tr><td class="paramname">flush</td><td>The flush function to use if the brigade is full </td></tr>
    <tr><td class="paramname">ctx</td><td>The structure to pass to the flush function </td></tr>
    <tr><td class="paramname">va</td><td>A list of strings to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>APR_SUCCESS or error code. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7242dae50995fc1a9174476ca3053d99"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">apr_status_t apr_brigade_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapr__bucket__brigade.html">apr_bucket_brigade</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_p_r___util___bucket___brigades.html#gacdf6dc9d4c81c64834e5e509281f7f16">apr_brigade_flush</a>&#160;</td>
          <td class="paramname"><em>flush</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t&#160;</td>
          <td class="paramname"><em>nbyte</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function writes a string into a bucket brigade.</p>
<p>The apr_brigade_write function attempts to be efficient with the handling of heap buckets. Regardless of the amount of data stored inside a heap bucket, heap buckets are a fixed size to promote their reuse.</p>
<p>If an attempt is made to write a string to a brigade that already ends with a heap bucket, this function will attempt to pack the string into the remaining space in the previous heap bucket, before allocating a new heap bucket.</p>
<p>This function always returns APR_SUCCESS, unless a flush function is passed, in which case the return value of the flush function will be returned if used. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>The bucket brigade to add to </td></tr>
    <tr><td class="paramname">flush</td><td>The flush function to use if the brigade is full </td></tr>
    <tr><td class="paramname">ctx</td><td>The structure to pass to the flush function </td></tr>
    <tr><td class="paramname">str</td><td>The string to add </td></tr>
    <tr><td class="paramname">nbyte</td><td>The number of bytes to write </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>APR_SUCCESS or error code </dd></dl>

</div>
</div>
<a class="anchor" id="gafc116a4359b717cd3a78a19ddf169486"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">apr_status_t apr_brigade_writev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapr__bucket__brigade.html">apr_bucket_brigade</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_p_r___util___bucket___brigades.html#gacdf6dc9d4c81c64834e5e509281f7f16">apr_brigade_flush</a>&#160;</td>
          <td class="paramname"><em>flush</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct iovec *&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t&#160;</td>
          <td class="paramname"><em>nvec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function writes multiple strings into a bucket brigade. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>The bucket brigade to add to </td></tr>
    <tr><td class="paramname">flush</td><td>The flush function to use if the brigade is full </td></tr>
    <tr><td class="paramname">ctx</td><td>The structure to pass to the flush function </td></tr>
    <tr><td class="paramname">vec</td><td>The strings to add (address plus length for each) </td></tr>
    <tr><td class="paramname">nvec</td><td>The number of entries in iovec </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>APR_SUCCESS or error code </dd></dl>

</div>
</div>
<a class="anchor" id="gae47c2235a3740432f4a0990fccfe4102"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* apr_bucket_alloc </td>
          <td>(</td>
          <td class="paramtype">apr_size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga9a30babfeb6e290db124d8f9b69e49e4">apr_bucket_alloc_t</a> *&#160;</td>
          <td class="paramname"><em>list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocate memory for use by the buckets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The amount to allocate. </td></tr>
    <tr><td class="paramname">list</td><td>The allocator from which to allocate the memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2d96fa729a17a86dc5221958e8c13c96"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga9a30babfeb6e290db124d8f9b69e49e4">apr_bucket_alloc_t</a>* apr_bucket_alloc_create </td>
          <td>(</td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a bucket allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>This pool's underlying apr_allocator_t is used to allocate memory for the bucket allocator. When the pool is destroyed, the bucket allocator's cleanup routine will free all memory that has been allocated from it. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The reason the allocator gets its memory from the pool's apr_allocator_t rather than from the pool itself is because the bucket allocator will free large memory blocks back to the allocator when it's done with them, thereby preventing memory footprint growth that would occur if we allocated from the pool. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The allocator must never be used by more than one thread at a time. </dd></dl>

</div>
</div>
<a class="anchor" id="ga252642139099350d0b987889d5c0868c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga9a30babfeb6e290db124d8f9b69e49e4">apr_bucket_alloc_t</a>* apr_bucket_alloc_create_ex </td>
          <td>(</td>
          <td class="paramtype">apr_allocator_t *&#160;</td>
          <td class="paramname"><em>allocator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a bucket allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">allocator</td><td>This apr_allocator_t is used to allocate both the bucket allocator and all memory handed out by the bucket allocator. The caller is responsible for destroying the bucket allocator and the apr_allocator_t &ndash; no automatic cleanups will happen. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>The allocator must never be used by more than one thread at a time. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf5eb58cc232851c8449ba1d98d049a0a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apr_bucket_alloc_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga9a30babfeb6e290db124d8f9b69e49e4">apr_bucket_alloc_t</a> *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroy a bucket allocator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The allocator to be destroyed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5fc17c10cee2abf02557669f6f507e89"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">apr_status_t apr_bucket_copy_notimpl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapr__bucket.html">apr_bucket</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapr__bucket.html">apr_bucket</a> **&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A place holder function that signifies that the copy function was not implemented for this bucket </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The bucket to copy </td></tr>
    <tr><td class="paramname">c</td><td>Returns a pointer to the new bucket </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>APR_ENOTIMPL </dd></dl>

</div>
</div>
<a class="anchor" id="ga09221bea9541ca2340a4e8b5e1e7ac56"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apr_bucket_destroy_noop </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A place holder function that signifies that this bucket does not need to do anything special to be destroyed. That's only the case for buckets that either have no data (metadata buckets) or buckets whose data pointer points to something that's not a bucket-type-specific structure, as with simple buckets where data points to a string and pipe buckets where data points directly to the apr_file_t. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The bucket data to destroy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaac308b459ecdab87e94b12adad1b8760"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapr__bucket.html">apr_bucket</a>* apr_bucket_eos_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga9a30babfeb6e290db124d8f9b69e49e4">apr_bucket_alloc_t</a> *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create an End of Stream bucket. This indicates that there is no more data coming from down the filter stack. All filters should flush at this point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The freelist from which this bucket should be allocated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new bucket, or NULL if allocation failed </dd></dl>

</div>
</div>
<a class="anchor" id="ga06312ba339cb0ec1844b698d30e754c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapr__bucket.html">apr_bucket</a>* apr_bucket_eos_make </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapr__bucket.html">apr_bucket</a> *&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make the bucket passed in an EOS bucket. This indicates that there is no more data coming from down the filter stack. All filters should flush at this point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>The bucket to make into an EOS bucket </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new bucket, or NULL if allocation failed </dd></dl>

</div>
</div>
<a class="anchor" id="ga421f96e8e9387a9c27fe010ebdee0202"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapr__bucket.html">apr_bucket</a>* apr_bucket_file_create </td>
          <td>(</td>
          <td class="paramtype">apr_file_t *&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_off_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga9a30babfeb6e290db124d8f9b69e49e4">apr_bucket_alloc_t</a> *&#160;</td>
          <td class="paramname"><em>list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a bucket referring to a file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>The file to put in the bucket </td></tr>
    <tr><td class="paramname">offset</td><td>The offset where the data of interest begins in the file </td></tr>
    <tr><td class="paramname">len</td><td>The amount of data in the file we are interested in </td></tr>
    <tr><td class="paramname">p</td><td>The pool into which any needed structures should be created while reading from this file bucket </td></tr>
    <tr><td class="paramname">list</td><td>The freelist from which this bucket should be allocated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new bucket, or NULL if allocation failed </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the file is truncated such that the segment of the file referenced by the bucket no longer exists, an attempt to read from the bucket will fail with APR_EOF. </dd>
<dd>
<a class="el" href="group___a_p_r___util___bucket___brigades.html#ga7c4981f7050333a181e440e753c20555">apr_brigade_insert_file()</a> should generally be used to insert files into brigades, since that function can correctly handle large file issues. </dd></dl>

</div>
</div>
<a class="anchor" id="gab18ee46f66634c35ad79b6a74559cbb8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">apr_status_t apr_bucket_file_enable_mmap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapr__bucket.html">apr_bucket</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>enabled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable or disable memory-mapping for a FILE bucket (default is enabled) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>The bucket </td></tr>
    <tr><td class="paramname">enabled</td><td>Whether memory-mapping should be enabled </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>APR_SUCCESS normally, or an error code if the operation fails </dd></dl>

</div>
</div>
<a class="anchor" id="gacb716dea400092f2f8c84a3f0f6d3a10"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapr__bucket.html">apr_bucket</a>* apr_bucket_file_make </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapr__bucket.html">apr_bucket</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_file_t *&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_off_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make the bucket passed in a bucket refer to a file </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>The bucket to make into a FILE bucket </td></tr>
    <tr><td class="paramname">fd</td><td>The file to put in the bucket </td></tr>
    <tr><td class="paramname">offset</td><td>The offset where the data of interest begins in the file </td></tr>
    <tr><td class="paramname">len</td><td>The amount of data in the file we are interested in </td></tr>
    <tr><td class="paramname">p</td><td>The pool into which any needed structures should be created while reading from this file bucket </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new bucket, or NULL if allocation failed </dd></dl>

</div>
</div>
<a class="anchor" id="ga48347f3f7d5738cdb61fe35c25c09666"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapr__bucket.html">apr_bucket</a>* apr_bucket_flush_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga9a30babfeb6e290db124d8f9b69e49e4">apr_bucket_alloc_t</a> *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a flush bucket. This indicates that filters should flush their data. There is no guarantee that they will flush it, but this is the best we can do. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The freelist from which this bucket should be allocated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new bucket, or NULL if allocation failed </dd></dl>

</div>
</div>
<a class="anchor" id="gaee543b95249a320a27ae9bb03e2c4f23"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapr__bucket.html">apr_bucket</a>* apr_bucket_flush_make </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapr__bucket.html">apr_bucket</a> *&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make the bucket passed in a FLUSH bucket. This indicates that filters should flush their data. There is no guarantee that they will flush it, but this is the best we can do. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>The bucket to make into a FLUSH bucket </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new bucket, or NULL if allocation failed </dd></dl>

</div>
</div>
<a class="anchor" id="ga951beb3a8249648214e130ab06275a3a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apr_bucket_free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Free memory previously allocated with <a class="el" href="group___a_p_r___util___bucket___brigades.html#gae47c2235a3740432f4a0990fccfe4102">apr_bucket_alloc()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>The block of memory to be freed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gadde6843cfe311a60d290adc1d6635cac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapr__bucket.html">apr_bucket</a>* apr_bucket_heap_create </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t&#160;</td>
          <td class="paramname"><em>nbyte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *data)&#160;</td>
          <td class="paramname"><em>free_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga9a30babfeb6e290db124d8f9b69e49e4">apr_bucket_alloc_t</a> *&#160;</td>
          <td class="paramname"><em>list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a bucket referring to memory on the heap. If the caller asks for the data to be copied, this function always allocates 4K of memory so that more data can be added to the bucket without requiring another allocation. Therefore not all the data may be put into the bucket. If copying is not requested then the bucket takes over responsibility for free()ing the memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The buffer to insert into the bucket </td></tr>
    <tr><td class="paramname">nbyte</td><td>The size of the buffer to insert. </td></tr>
    <tr><td class="paramname">free_func</td><td>Function to use to free the data; NULL indicates that the bucket should make a copy of the data </td></tr>
    <tr><td class="paramname">list</td><td>The freelist from which this bucket should be allocated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new bucket, or NULL if allocation failed </dd></dl>

</div>
</div>
<a class="anchor" id="ga71de285204d21507420068f05b12a541"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapr__bucket.html">apr_bucket</a>* apr_bucket_heap_make </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapr__bucket.html">apr_bucket</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t&#160;</td>
          <td class="paramname"><em>nbyte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *data)&#160;</td>
          <td class="paramname"><em>free_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make the bucket passed in a bucket refer to heap data </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>The bucket to make into a HEAP bucket </td></tr>
    <tr><td class="paramname">buf</td><td>The buffer to insert into the bucket </td></tr>
    <tr><td class="paramname">nbyte</td><td>The size of the buffer to insert. </td></tr>
    <tr><td class="paramname">free_func</td><td>Function to use to free the data; NULL indicates that the bucket should make a copy of the data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new bucket, or NULL if allocation failed </dd></dl>

</div>
</div>
<a class="anchor" id="gad81543da24b144c0e100dd1e6d843adb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapr__bucket.html">apr_bucket</a>* apr_bucket_immortal_create </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t&#160;</td>
          <td class="paramname"><em>nbyte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga9a30babfeb6e290db124d8f9b69e49e4">apr_bucket_alloc_t</a> *&#160;</td>
          <td class="paramname"><em>list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a bucket referring to long-lived data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The data to insert into the bucket </td></tr>
    <tr><td class="paramname">nbyte</td><td>The size of the data to insert. </td></tr>
    <tr><td class="paramname">list</td><td>The freelist from which this bucket should be allocated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new bucket, or NULL if allocation failed </dd></dl>

</div>
</div>
<a class="anchor" id="ga33b21eb55cad9d28b5cdd40ad4181774"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapr__bucket.html">apr_bucket</a>* apr_bucket_immortal_make </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapr__bucket.html">apr_bucket</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t&#160;</td>
          <td class="paramname"><em>nbyte</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make the bucket passed in a bucket refer to long-lived data </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>The bucket to make into a IMMORTAL bucket </td></tr>
    <tr><td class="paramname">buf</td><td>The data to insert into the bucket </td></tr>
    <tr><td class="paramname">nbyte</td><td>The size of the data to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new bucket, or NULL if allocation failed </dd></dl>

</div>
</div>
<a class="anchor" id="gaee338c7d218ce1fbbf8c1aefedcc0632"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapr__bucket.html">apr_bucket</a>* apr_bucket_mmap_create </td>
          <td>(</td>
          <td class="paramtype">apr_mmap_t *&#160;</td>
          <td class="paramname"><em>mm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_off_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga9a30babfeb6e290db124d8f9b69e49e4">apr_bucket_alloc_t</a> *&#160;</td>
          <td class="paramname"><em>list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a bucket referring to mmap()ed memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mm</td><td>The mmap to insert into the bucket </td></tr>
    <tr><td class="paramname">start</td><td>The offset of the first byte in the mmap that this bucket refers to </td></tr>
    <tr><td class="paramname">length</td><td>The number of bytes referred to by this bucket </td></tr>
    <tr><td class="paramname">list</td><td>The freelist from which this bucket should be allocated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new bucket, or NULL if allocation failed </dd></dl>

</div>
</div>
<a class="anchor" id="gab561ac92d1811e5a2589783536e64a1a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapr__bucket.html">apr_bucket</a>* apr_bucket_mmap_make </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapr__bucket.html">apr_bucket</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_mmap_t *&#160;</td>
          <td class="paramname"><em>mm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_off_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make the bucket passed in a bucket refer to an MMAP'ed file </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>The bucket to make into a MMAP bucket </td></tr>
    <tr><td class="paramname">mm</td><td>The mmap to insert into the bucket </td></tr>
    <tr><td class="paramname">start</td><td>The offset of the first byte in the mmap that this bucket refers to </td></tr>
    <tr><td class="paramname">length</td><td>The number of bytes referred to by this bucket </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new bucket, or NULL if allocation failed </dd></dl>

</div>
</div>
<a class="anchor" id="gab9ea07d5f9246e06c1bb3e76ee90cd71"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapr__bucket.html">apr_bucket</a>* apr_bucket_pipe_create </td>
          <td>(</td>
          <td class="paramtype">apr_file_t *&#160;</td>
          <td class="paramname"><em>thispipe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga9a30babfeb6e290db124d8f9b69e49e4">apr_bucket_alloc_t</a> *&#160;</td>
          <td class="paramname"><em>list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a bucket referring to a pipe. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thispipe</td><td>The pipe to put in the bucket </td></tr>
    <tr><td class="paramname">list</td><td>The freelist from which this bucket should be allocated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new bucket, or NULL if allocation failed </dd></dl>

</div>
</div>
<a class="anchor" id="gae7b4daa1318226beda4bf0eead2f5582"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapr__bucket.html">apr_bucket</a>* apr_bucket_pipe_make </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapr__bucket.html">apr_bucket</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_file_t *&#160;</td>
          <td class="paramname"><em>thispipe</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make the bucket passed in a bucket refer to a pipe </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>The bucket to make into a PIPE bucket </td></tr>
    <tr><td class="paramname">thispipe</td><td>The pipe to put in the bucket </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new bucket, or NULL if allocation failed </dd></dl>

</div>
</div>
<a class="anchor" id="ga154ea763ee9de4ccb8692b9e3b60ebb2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapr__bucket.html">apr_bucket</a>* apr_bucket_pool_create </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga9a30babfeb6e290db124d8f9b69e49e4">apr_bucket_alloc_t</a> *&#160;</td>
          <td class="paramname"><em>list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a bucket referring to memory allocated from a pool.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The buffer to insert into the bucket </td></tr>
    <tr><td class="paramname">length</td><td>The number of bytes referred to by this bucket </td></tr>
    <tr><td class="paramname">pool</td><td>The pool the memory was allocated from </td></tr>
    <tr><td class="paramname">list</td><td>The freelist from which this bucket should be allocated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new bucket, or NULL if allocation failed </dd></dl>

</div>
</div>
<a class="anchor" id="ga01197c5b2cda6382354628cecdeae145"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapr__bucket.html">apr_bucket</a>* apr_bucket_pool_make </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapr__bucket.html">apr_bucket</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make the bucket passed in a bucket refer to pool data </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>The bucket to make into a pool bucket </td></tr>
    <tr><td class="paramname">buf</td><td>The buffer to insert into the bucket </td></tr>
    <tr><td class="paramname">length</td><td>The number of bytes referred to by this bucket </td></tr>
    <tr><td class="paramname">pool</td><td>The pool the memory was allocated from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new bucket, or NULL if allocation failed </dd></dl>

</div>
</div>
<a class="anchor" id="gae6135b83d9f7bd7e1b60dbc761a3ca5f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">apr_status_t apr_bucket_setaside_noop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapr__bucket.html">apr_bucket</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function simply returns APR_SUCCESS to denote that the bucket does not require anything to happen for its setaside() function. This is appropriate for buckets that have "immortal" data &ndash; the data will live at least as long as the bucket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The bucket to setaside </td></tr>
    <tr><td class="paramname">pool</td><td>The pool defining the desired lifetime of the bucket data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>APR_SUCCESS </dd></dl>

</div>
</div>
<a class="anchor" id="gade52b057161f657a6b298d9c6a78b339"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">apr_status_t apr_bucket_setaside_notimpl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapr__bucket.html">apr_bucket</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_pool_t *&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A place holder function that signifies that the setaside function was not implemented for this bucket </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The bucket to setaside </td></tr>
    <tr><td class="paramname">pool</td><td>The pool defining the desired lifetime of the bucket data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>APR_ENOTIMPL </dd></dl>

</div>
</div>
<a class="anchor" id="ga2e9a035d340ef6b4279b178eff614670"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">apr_status_t apr_bucket_shared_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapr__bucket.html">apr_bucket</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapr__bucket.html">apr_bucket</a> **&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy a refcounted bucket, incrementing the reference count. Most reference-counting bucket types will be able to use this function as their copy function without any additional type-specific handling. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The bucket to copy </td></tr>
    <tr><td class="paramname">b</td><td>Returns a pointer to the new bucket </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>APR_ENOMEM if allocation failed; or APR_SUCCESS </dd></dl>

</div>
</div>
<a class="anchor" id="ga43c7dc7e3eb961a91bbc0b69a47e503c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int apr_bucket_shared_destroy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Decrement the refcount of the data in the bucket. This function should only be called by type-specific bucket destruction functions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The private data pointer from the bucket to be destroyed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE or FALSE; TRUE if the reference count is now zero, indicating that the shared resource itself can be destroyed by the caller. </dd></dl>

</div>
</div>
<a class="anchor" id="ga562251ac5776e88f7384158b85e74be8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapr__bucket.html">apr_bucket</a>* apr_bucket_shared_make </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapr__bucket.html">apr_bucket</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_off_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize a bucket containing reference-counted data that may be shared. The caller must allocate the bucket if necessary and initialize its type-dependent fields, and allocate and initialize its own private data structure. This function should only be called by type-specific bucket creation functions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>The bucket to initialize </td></tr>
    <tr><td class="paramname">data</td><td>A pointer to the private data structure with the reference count at the start </td></tr>
    <tr><td class="paramname">start</td><td>The start of the data in the bucket relative to the private base pointer </td></tr>
    <tr><td class="paramname">length</td><td>The length of the data in the bucket </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new bucket, or NULL if allocation failed </dd></dl>

</div>
</div>
<a class="anchor" id="ga871e54ba20487a2085a73a673ffa4110"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">apr_status_t apr_bucket_shared_split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapr__bucket.html">apr_bucket</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Split a bucket into two at the given point, and adjust the refcount to the underlying data. Most reference-counting bucket types will be able to use this function as their split function without any additional type-specific handling. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>The bucket to be split </td></tr>
    <tr><td class="paramname">point</td><td>The offset of the first byte in the new bucket </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>APR_EINVAL if the point is not within the bucket; APR_ENOMEM if allocation failed; or APR_SUCCESS </dd></dl>

</div>
</div>
<a class="anchor" id="ga123c95e832734f92e6f1139b6a68cfa6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">apr_status_t apr_bucket_simple_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapr__bucket.html">apr_bucket</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structapr__bucket.html">apr_bucket</a> **&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy a simple bucket. Most non-reference-counting buckets that allow multiple references to the same block of data (eg transient and immortal) will use this as their copy function without any additional type-specific handling. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The bucket to copy </td></tr>
    <tr><td class="paramname">b</td><td>Returns a pointer to the new bucket </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>APR_ENOMEM if allocation failed; or APR_SUCCESS </dd></dl>

</div>
</div>
<a class="anchor" id="ga9fd8c7d9e42dd04b8f153072655e875c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">apr_status_t apr_bucket_simple_split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapr__bucket.html">apr_bucket</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Split a simple bucket into two at the given point. Most non-reference counting buckets that allow multiple references to the same block of data (eg transient and immortal) will use this as their split function without any additional type-specific handling. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>The bucket to be split </td></tr>
    <tr><td class="paramname">point</td><td>The offset of the first byte in the new bucket </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>APR_EINVAL if the point is not within the bucket; APR_ENOMEM if allocation failed; or APR_SUCCESS </dd></dl>

</div>
</div>
<a class="anchor" id="gacd9f08b40eb2204cd93b42e58338aeb2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapr__bucket.html">apr_bucket</a>* apr_bucket_socket_create </td>
          <td>(</td>
          <td class="paramtype">apr_socket_t *&#160;</td>
          <td class="paramname"><em>thissock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga9a30babfeb6e290db124d8f9b69e49e4">apr_bucket_alloc_t</a> *&#160;</td>
          <td class="paramname"><em>list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a bucket referring to a socket. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">thissock</td><td>The socket to put in the bucket </td></tr>
    <tr><td class="paramname">list</td><td>The freelist from which this bucket should be allocated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new bucket, or NULL if allocation failed </dd></dl>

</div>
</div>
<a class="anchor" id="ga2fffd4c4701ad55c6df27cdee0c47200"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapr__bucket.html">apr_bucket</a>* apr_bucket_socket_make </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapr__bucket.html">apr_bucket</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_socket_t *&#160;</td>
          <td class="paramname"><em>thissock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make the bucket passed in a bucket refer to a socket </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>The bucket to make into a SOCKET bucket </td></tr>
    <tr><td class="paramname">thissock</td><td>The socket to put in the bucket </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new bucket, or NULL if allocation failed </dd></dl>

</div>
</div>
<a class="anchor" id="ga305766ff39440711da93e72f5b348a3a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">apr_status_t apr_bucket_split_notimpl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapr__bucket.html">apr_bucket</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A place holder function that signifies that the split function was not implemented for this bucket </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The bucket to split </td></tr>
    <tr><td class="paramname">point</td><td>The location to split the bucket </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>APR_ENOTIMPL </dd></dl>

</div>
</div>
<a class="anchor" id="ga554f2d87c718f30a9259d52c6f81a405"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapr__bucket.html">apr_bucket</a>* apr_bucket_transient_create </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t&#160;</td>
          <td class="paramname"><em>nbyte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___a_p_r___util___bucket___brigades.html#ga9a30babfeb6e290db124d8f9b69e49e4">apr_bucket_alloc_t</a> *&#160;</td>
          <td class="paramname"><em>list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a bucket referring to data on the stack. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The data to insert into the bucket </td></tr>
    <tr><td class="paramname">nbyte</td><td>The size of the data to insert. </td></tr>
    <tr><td class="paramname">list</td><td>The freelist from which this bucket should be allocated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new bucket, or NULL if allocation failed </dd></dl>

</div>
</div>
<a class="anchor" id="ga7e1f9a0ae64781ff4430d08c25e6e831"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structapr__bucket.html">apr_bucket</a>* apr_bucket_transient_make </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structapr__bucket.html">apr_bucket</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">apr_size_t&#160;</td>
          <td class="paramname"><em>nbyte</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make the bucket passed in a bucket refer to stack data </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>The bucket to make into a TRANSIENT bucket </td></tr>
    <tr><td class="paramname">buf</td><td>The data to insert into the bucket </td></tr>
    <tr><td class="paramname">nbyte</td><td>The size of the data to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new bucket, or NULL if allocation failed </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="ga829cac9b4843b85a902ddd64dffbfb12"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structapr__bucket__type__t.html">apr_bucket_type_t</a> apr_bucket_type_eos</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The EOS bucket type. This signifies that there will be no more data, ever. All filters MUST send all data to the next filter when they receive a bucket of this type </p>

</div>
</div>
<a class="anchor" id="ga5f17aa7e616179411a06475ec09626e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structapr__bucket__type__t.html">apr_bucket_type_t</a> apr_bucket_type_file</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The FILE bucket type. This bucket represents a file on disk </p>

</div>
</div>
<a class="anchor" id="gaecc113cfcc7751dfe70876437a2f51d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structapr__bucket__type__t.html">apr_bucket_type_t</a> apr_bucket_type_flush</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>There is no apr_bucket_destroy_notimpl, because destruction is required to be implemented (it could be a noop, but only if that makes sense for the bucket type) The flush bucket type. This signifies that all data should be flushed to the next filter. The flush bucket should be sent with the other buckets. </p>

</div>
</div>
<a class="anchor" id="ga2c5608267ed7b860657f5a1c89c2f40d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structapr__bucket__type__t.html">apr_bucket_type_t</a> apr_bucket_type_heap</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The HEAP bucket type. This bucket represents a data allocated from the heap. </p>

</div>
</div>
<a class="anchor" id="ga391ac24b2c85969e8efa504588b364bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structapr__bucket__type__t.html">apr_bucket_type_t</a> apr_bucket_type_immortal</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The IMMORTAL bucket type. This bucket represents a segment of data that the creator is willing to take responsibility for. The core will do nothing with the data in an immortal bucket </p>

</div>
</div>
<a class="anchor" id="ga63f9ce8e4d6e796921aad14a218a3b23"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structapr__bucket__type__t.html">apr_bucket_type_t</a> apr_bucket_type_mmap</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The MMAP bucket type. This bucket represents an MMAP'ed file </p>

</div>
</div>
<a class="anchor" id="ga334a875abb2908364a40abbfa80c401f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structapr__bucket__type__t.html">apr_bucket_type_t</a> apr_bucket_type_pipe</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The PIPE bucket type. This bucket represents a pipe to another program. </p>

</div>
</div>
<a class="anchor" id="ga87bace819fdbf07c12497a8289b3567b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structapr__bucket__type__t.html">apr_bucket_type_t</a> apr_bucket_type_pool</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The POOL bucket type. This bucket represents a data that was allocated from a pool. IF this bucket is still available when the pool is cleared, the data is copied on to the heap. </p>

</div>
</div>
<a class="anchor" id="gaa6d9978cc10895bdf0a4686728822a84"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structapr__bucket__type__t.html">apr_bucket_type_t</a> apr_bucket_type_socket</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The SOCKET bucket type. This bucket represents a socket to another machine </p>

</div>
</div>
<a class="anchor" id="ga1692ced61c1966e67adc05ec2a69ce9b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structapr__bucket__type__t.html">apr_bucket_type_t</a> apr_bucket_type_transient</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The TRANSIENT bucket type. This bucket represents a data allocated off the stack. When the setaside function is called, this data is copied on to the heap </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Dec 10 2013 16:23:17 for Apache Portable Runtime Utility Library by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
